<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>智能财务</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="智能财务">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="智能财务">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ma">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="智能财务" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">智能财务</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-vue6" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/19/vue6/" class="article-date">
  <time class="dt-published" datetime="2022-08-19T11:07:29.000Z" itemprop="datePublished">2022-08-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/19/vue6/">vue6</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p>路由器提供了两种机制: 路由和转送.</p>
<ul>
<li>路由是决定数据包从来源到目的地的路径.</li>
<li>转送将输入端的数据转移到合适的输出端.</li>
<li>路由中有一个非常重要的概念叫路由表.</li>
<li>路由表本质上就是一个映射表, 决定了数据包的指向</li>
</ul>
<p>先使用vue-cli构建一个项目，构建的时候选择vueroter<br>后端路由： 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；<br>前端路由： 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；不会涉及到页面刷新，只是切换组件</p>
<h3 id="前端前进和后退："><a href="#前端前进和后退：" class="headerlink" title="前端前进和后退："></a>前端前进和后退：</h3><pre><code>// 向前进
history.pushState(&#123;&#125;,&#39;name&#39;,&#39;login&#39;)
// 向后退
history.replaceState(&#123;&#125;,&#39;name&#39;,&#39;login&#39;)

// 向前进
history.go(1) === history.back()
// 向后退
history.go(-1) ===  history.forward()
</code></pre>
<p>vue-router了解</p>
<ul>
<li>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。</li>
<li>我们可以访问其官方网站对其进行学习: <a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></li>
</ul>
<p>vue-router是基于路由和组件的</p>
<ul>
<li>路由用于设定访问路径, 将路径和组件映射起来.</li>
<li>在vue-router的单页面应用中, 页面的路径的改变就是组件的切换.</li>
</ul>
<h1 id="6-1-vue-router配置"><a href="#6-1-vue-router配置" class="headerlink" title="6.1 vue-router配置"></a>6.1 vue-router配置</h1><p>在router目录下的 index.js 文件中添加如下配置：</p>
<pre><code>// 导入vueRouter
import VueRouter from &quot;vue-router&quot;;
import Vue from &quot;Vue&quot;;

// 1.通过Vue.use(plugin)，安装插件
Vue.use(VueRouter)
// 2.创建路由对象
const  router = new VueRouter(&#123;
  // 配置路由和组件相关的东西
  routers:[
    
  ]
&#125;)

// 3. 将router传入到Vue实例中

export default router
</code></pre>
<p>在 main.js 中使用即可</p>
<pre><code>import Vue from &#39;vue&#39;
import App from &#39;./App&#39;
// 导入router
import router from &#39;./router/index&#39;

Vue.config.productionTip = false

new Vue(&#123;
  el: &#39;#app&#39;,
  router,
  render: h =&gt; h(App)
&#125;)
</code></pre>
<h2 id="路由映射配置"><a href="#路由映射配置" class="headerlink" title="路由映射配置"></a>路由映射配置</h2><p>该标签是一个vue-router中已经内置的组件, 它会被渲染成一个标签<br>该标签会根据当前的路径, 动态渲染出不同的组件<br>网页的其他内容, 比如顶部的标题&#x2F;导航, 或者底部的一些版权信息等会和处于同一个等级<br>在路由切换时, 切换的是挂载的组件, 其他内容不会发生改变  </p>
<h3 id="在components下新建如下两个文件"><a href="#在components下新建如下两个文件" class="headerlink" title="在components下新建如下两个文件"></a>在components下新建如下两个文件</h3><p>About.vue：</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;about&quot;&gt;
    &lt;h2&gt;我是关于页标题&lt;/h2&gt;
    &lt;p&gt;我是关于页内容&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default &#123;
    name: &quot;About&quot;
  &#125;
&lt;/script&gt;

&lt;style scoped&gt;
  #about &#123;
    width: 300px;
    height: 300px;
    border: red solid 1px;

  &#125;
&lt;/style&gt;
</code></pre>
<p>Home.vue</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;home&quot;&gt;
    &lt;h2&gt;我是首页标题&lt;/h2&gt;
    &lt;p&gt;我是首页内容&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default &#123;
    name: &quot;Home&quot;
  &#125;
&lt;/script&gt;

&lt;style scoped&gt;
  #home &#123;
    width: 300px;
    height: 300px;
  border: red solid 1px;
  &#125;
&lt;/style&gt;
</code></pre>
<p>router 下的index.js中添加如下内容</p>
<pre><code>// 配置路由相关的信息
import VueRouter from &#39;vue-router&#39;
import Vue from &#39;vue&#39;

import Home from &#39;../components/Home&#39;
import About from &#39;../components/About&#39;

// 1.通过Vue.use(插件), 安装插件
Vue.use(VueRouter)

// 2.创建VueRouter对象
const routes = [
  &#123;
    path: &#39;&#39;,
    // redirect重定向,默认跳转路径
    redirect: &#39;/home&#39;
  &#125;,
  &#123;
    path: &#39;/home&#39;,
    component: Home
  &#125;,
  &#123;
    path: &#39;/about&#39;,
    component: About
  &#125;
]
const router = new VueRouter(&#123;
  // 配置路由和组件之间的应用关系
  routes,
  // 改变模式 默认是hash模式(有#号)
  mode: &#39;history&#39;,
  // 选择当前组件的时候需要添加的className
  linkActiveClass: &#39;active&#39;
&#125;)

// 3.将router对象传入到Vue实例
export default router
</code></pre>
<p>App.vue中添加如下内容：</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
&lt;!-- tag:以什么形式的标签进行渲染，
   replace：不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中
 --&gt;
      &lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace&gt;首页&lt;/router-link&gt;
      &lt;router-link to=&quot;/about&quot; tag=&quot;button&quot; replace&gt;关于&lt;/router-link&gt;
      &lt;!-- 此处是一个占位标签，当路由跳转到某个组件的时候，该组件中的内容就会被渲染到此标签中 --&gt;
       &lt;router-view&gt; &lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

export default &#123;
  name: &#39;App&#39;
&#125;
&lt;/script&gt;

&lt;style&gt;
  .active&#123;
      color: red;
  &#125;
&lt;/style&gt;
</code></pre>
<p>使用代码手动跳转</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
&lt;!--  自定义事件通过$router进行控制跳转  --&gt;
    &lt;button @click=&quot;homeClick&quot;   tag=&quot;button&quot; &gt;首页&lt;/button&gt;
    &lt;button @click=&quot;aboutClick&quot;   tag=&quot;button&quot; &gt;关于&lt;/button&gt;
       &lt;router-view&gt; &lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

export default &#123;
  name: &#39;App&#39;,
  methods:&#123;
   // Vue-router在所有组件里都加入了$router
    homeClick()&#123;

      console.log(&quot;homeClick&quot;)

      // this.$router.replace(&#39;/home&#39;) // 可以点浏览器回退
      this.$router.push(&#39;/home&#39;)    // 不可以点浏览器回退

    &#125;,
    aboutClick()&#123;

       this.$router.push(&#39;/about&#39;)
      // this.$router.replace(&#39;/about&#39;)
       console.log(&quot;aboutClick&quot;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;

&lt;style&gt;
  .active&#123;
      color: red;
  &#125;
&lt;/style&gt;
</code></pre>
<h1 id="动态路由-参数传递"><a href="#动态路由-参数传递" class="headerlink" title="动态路由(参数传递)"></a>动态路由(参数传递)</h1><p>某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：</p>
<ul>
<li>&#x2F;user&#x2F;userId,路径后面跟上用户的id  </li>
<li>这种path和Component的匹配关系，我们称之为动态路由(也是路由传递数据的一种方式)</li>
</ul>
<p>添加一个 User.vue</p>
<pre><code>&lt;template&gt;
    &lt;div id=&quot;user&quot;&gt;
      &lt;div id=&quot;home&quot;&gt;
        &lt;h2&gt;我是用户页标题&lt;/h2&gt;
        &lt;p&gt;我是用户页内容&lt;/p&gt;
        &lt;h2&gt;用户id:&#123;&#123;userId&#125;&#125;&lt;/h2&gt;
      &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123;
        name: &quot;User&quot;,
      computed:&#123;
          userId()&#123;
            // $route：指向的是当前活跃的路由
            return this.$route.params.userId;
          &#125;
      &#125;
    &#125;
&lt;/script&gt;

&lt;style scoped&gt;
#user&#123;
  width: 300px;
  height: 300px;
  border: red solid 1px;
&#125;
&lt;/style&gt;
</code></pre>
<p>在router目录下的index.js中添加如下配置：</p>
<pre><code>// 2.创建VueRouter对象
const routes = [
  &#123;
    path: &#39;&#39;,
    // redirect重定向,默认跳转路径
    redirect: &#39;/home&#39;
  &#125;,
  &#123;
    path: &#39;/home&#39;,
    component: Home
  &#125;,
  &#123;
    path: &#39;/about&#39;,
    component: About
  &#125;,&#123;
  path: &#39;/user/:userId&#39;,
    component: User
  &#125;
]
</code></pre>
<p>在 App.vue 中添加如下代码：</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;router-link  to=&quot;/home&quot; tag=&quot;button&quot; replace&gt;首页&lt;/router-link&gt;
    &lt;router-link  to=&quot;/about&quot; tag=&quot;button&quot; replace&gt;关于&lt;/router-link&gt;
    &lt;router-link  :to=&quot;&#39;/user/&#39;+userId&quot; tag=&quot;button&quot; replace&gt;用户&lt;/router-link&gt;
       &lt;router-view&gt; &lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

export default &#123;
  name: &#39;App&#39;,
  data()&#123;
    return &#123;userId:&quot;101&quot;&#125;
  &#125;
&#125;
&lt;/script&gt;

&lt;style&gt;
  .active&#123;
      color: red;
  &#125;
&lt;/style&gt;
</code></pre>
<h1 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h1><p>路由懒加载的意义</p>
<ul>
<li>当打包构建应用时，Javascript包会变得非常大，影响页面加载。</li>
<li>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了</li>
</ul>
<p>路由懒加载做了什么?</p>
<ul>
<li>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块.</li>
<li>只有在这个路由被访问到的时候, 才加载对应的组件</li>
</ul>
<p>懒加载的三种方式<br>方式一: 结合Vue的异步组件和Webpack的代码分析</p>
<pre><code>const Home = resolve =&gt; &#123; require.ensure([&#39;../components/Home.vue&#39;], () =&gt; &#123; resolve(require(&#39;../components/Home.vue&#39;)) &#125;)&#125;;
</code></pre>
<p>方式二: AMD写法</p>
<pre><code>const About = resolve =&gt; require([&#39;../components/About.vue&#39;], resolve);
</code></pre>
<p>方式三: 在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割</p>
<pre><code>const Home = () =&gt; import(&#39;../components/Home.vue&#39;)&lt;font color=&#39;red&#39;&gt;（最终使用）&lt;/font&gt;
</code></pre>
<h1 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h1><p>嵌套路由是一个很常见的功能</p>
<ul>
<li>比如在home页面中, 我们希望通过&#x2F;home&#x2F;news和&#x2F;home&#x2F;message访问一些内容.</li>
<li>一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件.</li>
</ul>
<h3 id="嵌套路由实现"><a href="#嵌套路由实现" class="headerlink" title="嵌套路由实现"></a>嵌套路由实现</h3><p>1.在components下准备两个组件作为Home的子组件  </p>
<p>HomeMessage.vue：</p>
<pre><code>&lt;template&gt;
&lt;div&gt;
  &lt;ul&gt;
    &lt;li&gt;消息0&lt;/li&gt;
    &lt;li&gt;消息1&lt;/li&gt;
    &lt;li&gt;消息2&lt;/li&gt;
    &lt;li&gt;消息3&lt;/li&gt;
    &lt;li&gt;消息4&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123;
        name: &quot;HomeMessage&quot;
    &#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>HomeNews.vue</p>
<pre><code>&lt;template&gt;
&lt;div&gt;
  &lt;ul&gt;
    &lt;li&gt;新闻0&lt;/li&gt;
    &lt;li&gt;新闻1&lt;/li&gt;
    &lt;li&gt;新闻2&lt;/li&gt;
    &lt;li&gt;新闻3&lt;/li&gt;
    &lt;li&gt;新闻4&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123;
        name: &quot;HomeNews&quot;
    &#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>2.在 router 下的 index.js 下降这两个组件注册为Home的子组件</p>
<pre><code>  &#123;
    path: &#39;/home&#39;,
    component: Home,
    children:[
      &#123;
        path:&#39;message&#39;,
        component:HomeMessage
      &#125;,
      &#123;
        path: &#39;news&#39;,
        component:HomeNews
      &#125;

    ]
  &#125;,
</code></pre>
<p>3.在 Home 页进行引用这两个组件</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;home&quot;&gt;
    &lt;h2&gt;我是首页标题&lt;/h2&gt;
    &lt;router-link to=&quot;/home/news&quot; tag=&quot;button&quot;&gt;新闻&lt;/router-link&gt;
    &lt;router-link to=&quot;/home/message&quot; tag=&quot;button&quot;&gt;消息&lt;/router-link&gt;
   &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p>参数传递，也就是从一个路由跳转到另外一个路由的时候，我们希望传递一些消息到跳转的路由</p>
<p>params的类型:</p>
<ul>
<li>配置路由格式: &#x2F;router&#x2F;:id</li>
<li>传递的方式: 在path后面跟上对应的值</li>
<li>传递后形成的路径: &#x2F;router&#x2F;123, &#x2F;router&#x2F;abc</li>
</ul>
<p>query的类型:</p>
<ul>
<li>配置路由格式: &#x2F;router, 也就是普通配置</li>
<li>传递的方式: 对象中使用query的key作为传递方式</li>
<li>传递后形成的路径: &#x2F;router?id&#x3D;123, &#x2F;router?id&#x3D;abc</li>
</ul>
<h3 id="实现方式1：通过query的方式"><a href="#实现方式1：通过query的方式" class="headerlink" title="实现方式1：通过query的方式"></a>实现方式1：通过query的方式</h3><p>1.准备 Profile.vue</p>
<pre><code>&lt;template&gt;
&lt;div&gt;
  &lt;h1&gt;我的档案&lt;/h1&gt;
  &lt;ul&gt;
    &lt;li&gt;姓名：&#123;&#123;$route.query.name&#125;&#125;&lt;/li&gt;
    &lt;li&gt;年龄：&#123;&#123;$route.query.age&#125;&#125;&lt;/li&gt;
    &lt;li&gt;性别：&#123;&#123;$route.query.sex&#125;&#125;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123;
        name: &quot;Profile&quot;,
    &#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>2.在 router 下的 index.js 下配置路由</p>
<pre><code>  &#123;
    path: &#39;/profile&#39;,
    component: Profile
  &#125;
</code></pre>
<p>3.在 App.vue 下配置如下内容</p>
<pre><code>&lt;router-link  :to=&quot;&#123;path: &#39;/profile&#39;, query: &#123;name: &#39;张三&#39;, age: 18,sex:&#39;男&#39;&#125;&#125;&quot;tag=&quot;button&quot; &gt;档案&lt;/router-link&gt;
</code></pre>
<h3 id="实现方式2：自定义点击事件"><a href="#实现方式2：自定义点击事件" class="headerlink" title="实现方式2：自定义点击事件"></a>实现方式2：自定义点击事件</h3><p>1.准备 Order.vue 页面</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
      &lt;h2&gt;订单页面&lt;/h2&gt;
      &lt;ul&gt;
        &lt;li&gt;订单号：&#123;&#123;$route.query.orderId&#125;&#125;&lt;/li&gt;
        &lt;li&gt;物品名称：&#123;&#123;$route.query.productName&#125;&#125;&lt;/li&gt;
        &lt;li&gt;价格：&#123;&#123;$route.query.price&#125;&#125;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123;
        name: &quot;Order&quot;,

    &#125;
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>2.在 router 下的 index.js 下配置路由	</p>
<pre><code> &#123;
    path: &#39;/order&#39;,
    component: Order
  &#125;
</code></pre>
<p>3.在 App.vue 添加如下配置</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;button @click=&quot;orderClick&quot;tag=&quot;button&quot; replace&gt;订单&lt;/button&gt;
    &lt;router-view&gt;&lt;/router-view&gt;

  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default &#123;
    name: &#39;App&#39;,
    methods: &#123;
      orderClick() &#123;
        this.$router.push(&#123;
          path: &#39;/order&#39;,
          query: &#123;orderId: 101, productName: &#39;奥特曼真皮大衣&#39;, price: 8888&#125;
        &#125;)
      &#125;

    &#125;,
   
  &#125;
&lt;/script&gt;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/19/vue6/" data-id="cl70ok8ht000144w9802xeddu" data-title="vue6" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vue5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/17/vue5/" class="article-date">
  <time class="dt-published" datetime="2022-08-17T13:22:23.000Z" itemprop="datePublished">2022-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/17/vue5/">vue5</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h1><p>CLI是什么意思?</p>
<ul>
<li>CLI是 Command-Line Interface, 翻译为命令行界面, 但是俗称脚手架.</li>
<li>Vue CLI是一个官方发布 vue.js 项目脚手架</li>
<li>使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置.</li>
</ul>
<h3 id="Vue-cli2初始化"><a href="#Vue-cli2初始化" class="headerlink" title="Vue-cli2初始化"></a>Vue-cli2初始化</h3><p>Vue CLI2初始化项目：vue init webpack projectName(执行该命令)<br>Vue CLI3初始化项目： vue create projectName</p>
<h3 id="项目目录结构解析"><a href="#项目目录结构解析" class="headerlink" title="项目目录结构解析"></a>项目目录结构解析</h3><p>build目录: webpack.base.conf.js是webpack的公共配置；webpack.dev.conf.js是开发时配置；webpack.prod.conf.js是发布时配置</p>
<p>config目录: 该文件夹中主要都是一些变量的配置，比如index.js，里面会有一些变量的配置，这些变量会被上面的builid文件夹里面的js文件所引用。当然了，index.js中的变量值也是可以自定义改变的。所以说config文件夹和build文件夹都是webpack的相关配置。</p>
<p>node_modules目录: 该文件夹中存放的是项目依赖的包</p>
<p>.babelrc文件：.babelrc主要就是对哪些浏览器可以进行es6转es5进行了限制。如果该浏览器占市场的份额大于1%且该浏览器的版本是它的最新的两个版本之一，那么可以进行es6到es5的转换。如果该浏览器是版本小于8的IE浏览器，那不要直接不考虑转换。总之，.babelrc就是在进行es转换的时候需要读取的配置文件。</p>
<p>.editorconfig: 该文件主要就是对代码进行一些统一的设置</p>
<p>.eslintignore: 表示我们在写代码的时候，有些文件夹里面的代码就算写的不太规范，但是我们也可以忽略它的不规范，在这个文件里面配置。</p>
<p>slintrc.js文件: 用于设置如何进行代码检查。</p>
<p>.gitignore文件: 表示当我们向服务器上传东西的时候，有些东西是可以不要上传的，可以在该文件中配置哪些东西不上传。</p>
<p>.postcssrc.js文件: 项目在进行css转换的时候，所需要读取的配置文件。</p>
<p>index.html文件: html文件的一个模板，打包的时候会以这个index.html为模板生成一个html文件放入dist文件夹中。</p>
<p>package.json文件: 主要用于对项目所依赖包的配置和一些指令的设定(scripts属性)。</p>
<h1 id="vue-cli3"><a href="#vue-cli3" class="headerlink" title="vue-cli3"></a>vue-cli3</h1><ul>
<li>vue-cli 3 是基于 webpack 4 打造，vue-cli 2 还是 webapck 3</li>
<li>vue-cli 3 的设计原则是“0配置”，移除的配置文件根目录下的，build和config等目录</li>
<li>vue-cli 3 提供了 vue ui 命令，提供了可视化配置，更加人性化</li>
<li>移除了static文件夹，新增了public文件夹，并且index.html移动到public中</li>
</ul>
<p>修改vue配置信息方式：</p>
<p>vue-cli3图形化界面配置：在控制台输入： vue ui<br>在 node_modules&#x2F;@vue&#x2F;cli-service下进行修改<br>在当前项目目录下 创建 vue.config.js 自定义配置  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/17/vue5/" data-id="cl70ok8hw000244w9gn0v3l9o" data-title="vue5" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vue4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/16/vue4/" class="article-date">
  <time class="dt-published" datetime="2022-08-16T14:42:56.000Z" itemprop="datePublished">2022-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/16/vue4/">vue4</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="webpack模块化开发"><a href="#webpack模块化开发" class="headerlink" title="webpack模块化开发"></a>webpack模块化开发</h1><p>目录结构：<br>WEBPACK-DEMO<br>│  package.json<br>│  webpack.config.js<br>│<br>├─dist<br>├─node_modules<br>└─src<br>      index.html<br>      main.js  </p>
<h1 id="webpack安装"><a href="#webpack安装" class="headerlink" title="webpack安装"></a>webpack安装</h1><p>Vue.js官方脚手架工具就使用了webpack模板  </p>
<ul>
<li>对所有的资源会压缩等优化操作，核心两个功能 模块化和打包  </li>
<li>它在开发过程中提供了一套完整的功能，能够使得我们开发过程中变得高效</li>
<li>安装webpack之前先安装node，并且配置环境变量 node-v 查看是否安装node环境</li>
<li>配置阿里云镜像：npm config set registry <a target="_blank" rel="noopener" href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org/</a></li>
<li>检测是否配置成功 npm config get registry</li>
<li>安装命令（全局安装）：cnpm install <a href="mailto:&#119;&#101;&#x62;&#112;&#x61;&#x63;&#x6b;&#64;&#51;&#46;&#54;&#46;&#48;">&#119;&#101;&#x62;&#112;&#x61;&#x63;&#x6b;&#64;&#51;&#46;&#54;&#46;&#48;</a> -g</li>
<li>测试是否安装成功：webpack -v</li>
</ul>
<h1 id="webpack入门使用"><a href="#webpack入门使用" class="headerlink" title="webpack入门使用"></a>webpack入门使用</h1><p>index.html 只需要引入bundle.js即可，webpack打包的时候会将依赖到的都引入进来</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;../dist/bundle.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h1><pre><code>const &#123;add, mul&#125; = require(&#39;./mathUtil.js&#39;)
console.log(add(20,30));
console.log(mul(20,30));
</code></pre>
<p>#mathUtil.js</p>
<pre><code>function add(number1,number2) &#123;
        return number1+number2;
&#125;

function mul(number1,number2) &#123;
        return number2*number1;
&#125;

module.exports = &#123;
        add,
        mul
&#125;

-------------------------------------------ES6模块化---------------------------------------------------------
 // 导出  
    export &#123;
        add,mul
&#125;
// 导入
    import &#123;name, age, height&#125; from &quot;./info&quot;;
</code></pre>
<h1 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h1><p>初始化项目：cnpm init</p>
<pre><code>package name: (02webpack配置) meetwebpack(包名)
version: (1.0.0)
description: webpack-init(描述)
entry point: (webpack.config.js) index.js(入口文件)
test command:
git repository:
keywords:
author:
license: (ISC)
About to write to C:\Users\11058\Desktop\web学习\webpack\package.json:
</code></pre>
<p>在项目下，新建一个文件 webpack.config.js</p>
<pre><code>// 从node中导入
const path=require(&#39;path&#39;)
module.exports=&#123;
    // 入口
    entry:&#39;./src/main.js&#39;,
    // 出口
    output:&#123;
        // 将当前路径和dist进行拼接
        path: path.resolve(__dirname, &#39;dist&#39;),
        filename:&#39;bundle.js&#39;
    &#125;
&#125;
</code></pre>
<p>在 package.json 的script中配置命令 直接使用 npm run build 代替 webpack 命令</p>
<pre><code>  &quot;scripts&quot;: &#123;
     // 优先从本地webpack中找，如果本地没有就去全局中找 [使用脚本使用的就是本地的，否则都是使用的是全局的]
     // 如果想通过cm命令的方式使用本地webpack，那么就在node_modules/bin目录下执行：webpack命令 
    &quot;build&quot;: &quot;webpack&quot;
  &#125;
</code></pre>
<p>在项目本地安装 webpack 命令： npm install <a href="mailto:&#119;&#x65;&#98;&#112;&#x61;&#x63;&#x6b;&#x40;&#51;&#46;&#54;&#x2e;&#48;">&#119;&#x65;&#98;&#112;&#x61;&#x63;&#x6b;&#x40;&#51;&#46;&#54;&#x2e;&#48;</a> –save-dev</p>
<p>webpack本身来说无法处理css, 图片, 高级ES6转化ES5的能力, 需要webpack扩展对应的loader</p>
<h3 id="css-loader配置"><a href="#css-loader配置" class="headerlink" title="css-loader配置:"></a>css-loader配置:</h3><p>加载 CSS 文件并解析 import 的 CSS 文件，最终返回 CSS 代码</p>
<p>1.安装css-loader: npm install <a href="mailto:&#115;&#x74;&#x79;&#108;&#101;&#45;&#108;&#x6f;&#x61;&#100;&#101;&#x72;&#64;&#50;&#x2e;&#x30;&#x2e;&#50;">&#115;&#x74;&#x79;&#108;&#101;&#45;&#108;&#x6f;&#x61;&#100;&#101;&#x72;&#64;&#50;&#x2e;&#x30;&#x2e;&#50;</a> –save-dev<br>2.在main.js中依赖normal.css[ require(’.&#x2F;css&#x2F;normal.css’) ]<br>3.在webpack.config.js中进行配置</p>
<pre><code>   module: &#123;
        // 配置规则
        rules: [
            &#123;
                test: /\.css$/,
                use: [ &quot;css-loader&quot;],
            &#125;,
        ],
    &#125;,
</code></pre>
<h3 id="style-loader配置"><a href="#style-loader配置" class="headerlink" title="style-loader配置 :"></a>style-loader配置 :</h3><p>安装往css-loader后，并不能进行解析运行，css-loader只负责加载进来，需要额外的在安装style-loader</p>
<p>1.安装style-loader: npm install <a href="mailto:&#x73;&#116;&#x79;&#108;&#x65;&#45;&#108;&#x6f;&#97;&#100;&#x65;&#114;&#64;&#48;&#46;&#x32;&#51;&#x2e;&#49;">&#x73;&#116;&#x79;&#108;&#x65;&#45;&#108;&#x6f;&#97;&#100;&#x65;&#114;&#64;&#48;&#46;&#x32;&#51;&#x2e;&#49;</a> –save-dev<br>2.在webpack.config.js中进行配置 ,在use中添加一个 style-loader 即可</p>
<h3 id="less-loader配置"><a href="#less-loader配置" class="headerlink" title="less-loader配置:"></a>less-loader配置:</h3><p>1.安装 less-loader: npm install <a href="mailto:&#x6c;&#101;&#x73;&#x73;&#45;&#x6c;&#x6f;&#97;&#x64;&#101;&#114;&#64;&#x34;&#46;&#49;&#46;&#48;">&#x6c;&#101;&#x73;&#x73;&#45;&#x6c;&#x6f;&#97;&#x64;&#101;&#114;&#64;&#x34;&#46;&#49;&#46;&#48;</a> –save-dev<br>2.在webpack.config.js中进行配置<br>3.在rules中的第二个下标中配置该对象  </p>
<pre><code>        &#123;
            test: /\.less$/,
           // 使用多个loader时，从右向左进行加载,使用对象还可以传递参数： &#123; loader:&quot;less-loader&quot;,arg:value&#125;,
            use:[
                &#123;loader:&quot;style-loader&quot;&#125;,
                &#123;loader:&quot;css-loader&quot;&#125;,
                &#123;loader:&quot;less-loader&quot;&#125;
            ]
        &#125;,
</code></pre>
<h3 id="url-loader配置：用于打包图片"><a href="#url-loader配置：用于打包图片" class="headerlink" title="url-loader配置：用于打包图片"></a>url-loader配置：用于打包图片</h3><p>1.安装url-loader: npm install –save-dev <a href="mailto:&#117;&#114;&#108;&#x2d;&#108;&#x6f;&#97;&#x64;&#101;&#114;&#64;&#x31;&#x2e;&#49;&#46;&#x32;">&#117;&#114;&#108;&#x2d;&#108;&#x6f;&#97;&#x64;&#101;&#114;&#64;&#x31;&#x2e;&#49;&#46;&#x32;</a><br>2.在webpack.config.js中进行配置 注意根据这些版本来，否则不指定版本，会出现问题</p>
<pre><code>&#123;
            test: /\.(png|jpg|gif)$/,
            use: [
                &#123;
                    loader: &#39;url-loader&#39;,
                    options: &#123;
                        // 限制文件的大小,当加载的图片大于限制的时候使用file-loader进行加载，
                        // 小于limit将图片编译为base64字符串进行显示
                        limit:625664,
                    &#125;,
                &#125;,
            ],
        &#125;
</code></pre>
<h3 id="file-loader-安装命令：npm-install-102-105-108-x65-x2d-x6c-x6f-x61-x64-101-x72-x40-50-x2e-x30-x2e-x30-–save-dev-解决图片超过limit大小时无法进行打包或显示"><a href="#file-loader-安装命令：npm-install-102-105-108-x65-x2d-x6c-x6f-x61-x64-101-x72-x40-50-x2e-x30-x2e-x30-–save-dev-解决图片超过limit大小时无法进行打包或显示" class="headerlink" title="file-loader: 安装命令：npm install &#102;&#105;&#108;&#x65;&#x2d;&#x6c;&#x6f;&#x61;&#x64;&#101;&#x72;&#x40;&#50;&#x2e;&#x30;&#x2e;&#x30; –save -dev (解决图片超过limit大小时无法进行打包或显示)"></a>file-loader: 安装命令：npm install <a href="mailto:&#102;&#105;&#108;&#x65;&#x2d;&#x6c;&#x6f;&#x61;&#x64;&#101;&#x72;&#x40;&#50;&#x2e;&#x30;&#x2e;&#x30;">&#102;&#105;&#108;&#x65;&#x2d;&#x6c;&#x6f;&#x61;&#x64;&#101;&#x72;&#x40;&#50;&#x2e;&#x30;&#x2e;&#x30;</a> –save -dev (解决图片超过limit大小时无法进行打包或显示)</h3><pre><code>   output:&#123;
        // 将当前路径和dist进行拼接
        path: path.resolve(__dirname, &#39;dist&#39;),
        filename:&#39;bundle.js&#39;,
        // 从dist目录下开始寻找资源
        publicPath:&#39;dist/&#39;
    &#125;,
  ----------------------------------------在rules添加如下配置-------------------------------------------------------
           &#123;
                test: /\.(png|jpg|gif)$/,
                use: [
                    &#123;
                        loader: &#39;url-loader&#39;,
                        options: &#123;
                            // 限制文件的大小,当加载的图片大于限制的时候使用file-loader进行加载，
                            // 小于limit将图片编译为base64字符串进行显示
                            limit:13000, //625664
                            // 设置打包路径和文件名
                            name:&#39;img/[name].[hash:8].[ext]&#39;
                        &#125;,
                    &#125;,
                ],
            &#125;
</code></pre>
<h3 id="ES6语法转ES5语法"><a href="#ES6语法转ES5语法" class="headerlink" title="ES6语法转ES5语法"></a>ES6语法转ES5语法</h3><p>1.安装对应的依赖： npm install –save-dev babel-loader@7 babel-core babel-preset-es2015<br>2.配置 webpack.config.js</p>
<pre><code>     &#123;
            test: /\.m?js$/,
            // 在进行ES6转ES5时只对src目录下js进行转化
            exclude: /(node_modules|bower_components)/,
            use: &#123;
                loader: &#39;babel-loader&#39;,
                options: &#123;
                    presets: [&#39;es2015&#39;]
                &#125;
            &#125;
        &#125;
</code></pre>
<h3 id="配置Vue环境"><a href="#配置Vue环境" class="headerlink" title="配置Vue环境"></a>配置Vue环境</h3><p>1.先进行安装 npm install vue –save<br>2.在mian.js中写入如下测试代码</p>
<pre><code>const app = new Vue(&#123;
    el:&#39;#app&#39;,
    message:&#39;hello world&#39;,
    methods:&#123;
        showMessage()&#123;
            console.log(&quot;welcome to Vue&quot;)
        &#125;
    &#125;
&#125;)
</code></pre>
<p>3.在index.html中写一个app</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;button @click=&quot;showMessage&quot;&gt; 按钮 &lt;/button&gt;
&lt;/div&gt;
// 把引入bundle.js放在后面，避免元素未加载完，js代码开始执行找不到dom
</code></pre>
<p>4.解决错误：</p>
<p>方式1：import Vue from ‘vue&#x2F;dist&#x2F;vue.esm.js’<br>方式2：在webpack.config.js中添加如下代码，和moudle同级</p>
<pre><code>resolve: &#123;
    alias: &#123;
        &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39; //内部为正则表达式  vue结尾的
    &#125;
&#125;
</code></pre>
<h3 id="安装vue-loader-npm-install-x76-x75-x65-45-108-111-97-x64-x65-114-64-x31-x35-x2e-52-x2e-50-x76-117-x65-x2d-x74-x65-x6d-112-108-97-x74-x65-45-x63-x6f-109-x70-x69-x6c-101-114-x40-x32-46-x36-x2e-49-x34-–save-dev"><a href="#安装vue-loader-npm-install-x76-x75-x65-45-108-111-97-x64-x65-114-64-x31-x35-x2e-52-x2e-50-x76-117-x65-x2d-x74-x65-x6d-112-108-97-x74-x65-45-x63-x6f-109-x70-x69-x6c-101-114-x40-x32-46-x36-x2e-49-x34-–save-dev" class="headerlink" title="安装vue-loader : npm install &#x76;&#x75;&#x65;&#45;&#108;&#111;&#97;&#x64;&#x65;&#114;&#64;&#x31;&#x35;&#x2e;&#52;&#x2e;&#50; &#x76;&#117;&#x65;&#x2d;&#x74;&#x65;&#x6d;&#112;&#108;&#97;&#x74;&#x65;&#45;&#x63;&#x6f;&#109;&#x70;&#x69;&#x6c;&#101;&#114;&#x40;&#x32;&#46;&#x36;&#x2e;&#49;&#x34;–save-dev"></a>安装vue-loader : npm install <a href="mailto:&#x76;&#x75;&#x65;&#45;&#108;&#111;&#97;&#x64;&#x65;&#114;&#64;&#x31;&#x35;&#x2e;&#52;&#x2e;&#50;">&#x76;&#x75;&#x65;&#45;&#108;&#111;&#97;&#x64;&#x65;&#114;&#64;&#x31;&#x35;&#x2e;&#52;&#x2e;&#50;</a> <a href="mailto:&#x76;&#117;&#x65;&#x2d;&#x74;&#x65;&#x6d;&#112;&#108;&#97;&#x74;&#x65;&#45;&#x63;&#x6f;&#109;&#x70;&#x69;&#x6c;&#101;&#114;&#x40;&#x32;&#46;&#x36;&#x2e;&#49;&#x34;">&#x76;&#117;&#x65;&#x2d;&#x74;&#x65;&#x6d;&#112;&#108;&#97;&#x74;&#x65;&#45;&#x63;&#x6f;&#109;&#x70;&#x69;&#x6c;&#101;&#114;&#x40;&#x32;&#46;&#x36;&#x2e;&#49;&#x34;</a>–save-dev</h3><p>在配置文件中做以下修改：</p>
<pre><code>       &#123;
            test: /\.vue$/,
            use: &#123;
                loader: &#39;vue-loader&#39;,
            &#125;
        &#125;
</code></pre>
<p>在vue目录下新建AApp.vue代替app.js ,内容如下：</p>
<pre><code>&lt;!-- 组件模板代码 --&gt;
&lt;template&gt;
    &lt;div&gt;
        &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;
        &lt;button @click=&quot;showMessage&quot;&gt; 按钮&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;!-- js代码 --&gt;
&lt;script&gt;
    export default &#123;
        name: &#39;App&#39;,
        data() &#123;
            return &#123;
                message: &quot;hello world&quot;
            &#125;
        &#125;,
        methods: &#123;
            showMessage() &#123;
                alert(&quot;welcome to Vue&quot;);
            &#125;
        &#125;
    &#125;
&lt;/script&gt;

&lt;!-- 写css代码 --&gt;
&lt;style scoped&gt;
    .title &#123;
        color: #ff0000
    &#125;
&lt;/style&gt;
</code></pre>
<p>在 main.js 中使用即可</p>
<pre><code>//引入App.vue
import App from &quot;./vue/App.vue&quot;;

new Vue(&#123;
    el: &#39;#app&#39;,
    template:&#39;&lt;App/&gt;&#39;,
    components:&#123; App &#125;

&#125;)
</code></pre>
<h1 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h1><h3 id="配置BannerPulgin"><a href="#配置BannerPulgin" class="headerlink" title="配置BannerPulgin:"></a>配置BannerPulgin:</h3><p>在webpack.config.js引入webpack</p>
<pre><code>const webpack=require(&#39;webpack&#39;)
</code></pre>
<p>2.在moudle同级下配置插件</p>
<pre><code>// 插件
plugins:[
    // 版权信息插件
    new webpack.BannerPlugin(&#39;最终版权归test所有&#39;)
]
</code></pre>
<h3 id="配置HtmlWebpackPlugin"><a href="#配置HtmlWebpackPlugin" class="headerlink" title="配置HtmlWebpackPlugin"></a>配置HtmlWebpackPlugin</h3><p>该插件将 index.html 打包到 buildle.js 中去</p>
<p>1.安装该插件:npm install <a href="mailto:&#x68;&#116;&#109;&#108;&#x2d;&#x77;&#101;&#x62;&#112;&#x61;&#99;&#x6b;&#x2d;&#x70;&#x6c;&#117;&#103;&#x69;&#110;&#64;&#x32;&#x2e;&#x33;&#x30;&#x2e;&#x31;">&#x68;&#116;&#109;&#108;&#x2d;&#x77;&#101;&#x62;&#112;&#x61;&#99;&#x6b;&#x2d;&#x70;&#x6c;&#117;&#103;&#x69;&#110;&#64;&#x32;&#x2e;&#x33;&#x30;&#x2e;&#x31;</a> –save-dev<br>2.注释掉webpack.config.js中的publicPath:‘dist&#x2F;’<br>3.在webpack.config.js中引入const htmlWebpackPlugin &#x3D; require(‘html-webpack-plugin’)<br>4.在webpack.config.js中配置new htmlWebpackPlugin({template:‘index.html’ })  </p>
<h3 id="配置uglifyjs"><a href="#配置uglifyjs" class="headerlink" title="配置uglifyjs:"></a>配置uglifyjs:</h3><p>对buildle.js进行压缩  </p>
<p>1.安装 npm install <a href="mailto:&#117;&#103;&#x6c;&#x69;&#x66;&#x79;&#106;&#115;&#x2d;&#119;&#x65;&#98;&#112;&#97;&#99;&#107;&#x2d;&#x70;&#108;&#117;&#103;&#x69;&#x6e;&#x40;&#x31;&#46;&#x31;&#46;&#x31;">&#117;&#103;&#x6c;&#x69;&#x66;&#x79;&#106;&#115;&#x2d;&#119;&#x65;&#98;&#112;&#97;&#99;&#107;&#x2d;&#x70;&#108;&#117;&#103;&#x69;&#x6e;&#x40;&#x31;&#46;&#x31;&#46;&#x31;</a> –save-dev<br>2.在 webpack.config.js 中引入 const uglifyJsPlugin &#x3D; require(‘uglifyjs-webpack-plugin’)<br>3.在 webpack.config.js 中配置 new uglifyJsPlugin()  </p>
<h3 id="使用-webpack-搭建本地服务器"><a href="#使用-webpack-搭建本地服务器" class="headerlink" title="使用 webpack 搭建本地服务器"></a>使用 webpack 搭建本地服务器</h3><p>1.安装npm install <a href="mailto:&#x77;&#101;&#98;&#112;&#97;&#x63;&#x6b;&#45;&#100;&#101;&#118;&#45;&#115;&#101;&#114;&#x76;&#x65;&#114;&#x40;&#50;&#46;&#x39;&#x2e;&#49;">&#x77;&#101;&#98;&#112;&#97;&#x63;&#x6b;&#45;&#100;&#101;&#118;&#45;&#115;&#101;&#114;&#x76;&#x65;&#114;&#x40;&#50;&#46;&#x39;&#x2e;&#49;</a> –save-dev<br>2.在package.json中的script中配置”dev”:”webpack-dev-server”<br>3.在webpack.config.js中添加如下配置</p>
<pre><code>// 加载本地服务器
devServer: &#123;
    contentBase: &#39;./dist&#39;,
    // 实时监听页面
    inline: true,
    // 80端口
    port: 80,
    // 如下 npm run dev 后自动打开浏览器
    open: true,
&#125;
</code></pre>
<h3 id="配置文件的分离抽取："><a href="#配置文件的分离抽取：" class="headerlink" title="配置文件的分离抽取："></a>配置文件的分离抽取：</h3><p>1.安装 npm install webpack-merge –save -dev</p>
<p>base.config.js: 开发时和运行时都需要的配置</p>
<pre><code>// 从node中导入
const path=require(&#39;path&#39;)
// 引入插件
const webpack=require(&#39;webpack&#39;)
const htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)
module.exports=&#123;
    // 入口
    entry:&#39;./src/main.js&#39;,
    // 出口
    output:&#123;
        // 将当前路径和dist进行拼接
        path: path.resolve(__dirname, &#39;../dist&#39;),
        filename:&#39;bundle.js&#39;,
        // 从dist目录下开始寻找资源
        // publicPath:&#39;dist/&#39;
    &#125;,

    module: &#123;
        // 配置规则
        rules: [
            &#123;
                test: /\.css$/,
                // css-loader:只负责将css进行加载,不负责解析和加载到index.html中
                // style-loader ：将模块导出的内容作为样式并添加到 DOM 中
                use: [ &quot;style-loader&quot;,&quot;css-loader&quot;],
            &#125;,
            &#123;
                test: /\.less$/,
                // 使用多个loader时，从右向左进行加载,使用对象还可以传递参数： &#123; loader:&quot;less-loader&quot;,arg:value&#125;,
                use:[
                    &#123;loader:&quot;style-loader&quot;&#125;,
                    &#123;loader:&quot;css-loader&quot;&#125;,
                    &#123;loader:&quot;less-loader&quot;&#125;
                ]
            &#125;,
            &#123;
                test: /\.(png|jpg|gif)$/,
                use: [
                    &#123;
                        loader: &#39;url-loader&#39;,
                        options: &#123;
                            // 限制文件的大小,当加载的图片大于限制的时候使用file-loader进行加载，
                            // 小于limit将图片编译为base64字符串进行显示
                            limit:13000, //625664
                            // 设置打包路径和文件名
                            name:&#39;img/[name].[hash:8].[ext]&#39;
                        &#125;,
                    &#125;,
                ],
            &#125;,
            &#123;
                test: /\.m?js$/,
                // 在进行ES6转ES5时只对src目录下js进行转化
                exclude: /(node_modules|bower_components)/,
                use: &#123;
                    loader: &#39;babel-loader&#39;,
                    options: &#123;
                        presets: [&#39;es2015&#39;]
                    &#125;
                &#125;
            &#125;,
            &#123;
                test: /\.vue$/,
                use: &#123;
                    loader: &#39;vue-loader&#39;,
                &#125;
            &#125;
        ],

    &#125;,
    // 解析
    resolve: &#123;
        extensions:[&#39;.css&#39;,&#39;.js&#39;,&#39;.vue&#39;],
        alias: &#123;
            &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39; //内部为正则表达式  vue结尾的
        &#125;
    &#125;,
    // 插件
    plugins:[
        // 版权信息插件
        new webpack.BannerPlugin(&#39;最终版权归test所有&#39;),
        new htmlWebpackPlugin(&#123;
            template:&#39;index.html&#39;
        &#125;),
    ],

&#125;
</code></pre>
<h3 id="dev-config-js-开发时配置"><a href="#dev-config-js-开发时配置" class="headerlink" title="dev.config.js: 开发时配置"></a>dev.config.js: 开发时配置</h3><pre><code>// proud.config.js:开发时需要的配置
const  baseConfig = require(&#39;./base.config.js&#39;)
const  webpackMerge=require(&#39;webpack-merge&#39;)
// 将base.config和dev.config.js进行合并

module.exports = webpackMerge.merge(baseConfig,&#123;
    // 加载本地服务器
    devServer: &#123;
        contentBase: &#39;./dist&#39;,
        // 实时监听页面
        inline: true,
        // 80端口
        port: 80,
        // 如下 npm run dev 后自动打开浏览器
        open: true,
    &#125;
&#125;)
</code></pre>
<h3 id="proud-config-js-运行时配置"><a href="#proud-config-js-运行时配置" class="headerlink" title="proud.config.js: 运行时配置"></a>proud.config.js: 运行时配置</h3><pre><code>// proud.config.js:运行时都需要的配置
const uglifyJsPlugin = require(&#39;uglifyjs-webpack-plugin&#39;)
const  baseConfig = require(&#39;./base.config.js&#39;)
const  webpackMerge=require(&#39;webpack-merge&#39;)

// 将base.config和proud.config.js进行合并
module.exports=webpackMerge.merge(baseConfig,&#123;
    // 插件
    plugins:[
        // 进行压缩
        new uglifyJsPlugin()
    ],
&#125;)
</code></pre>
<h3 id="在-package-json-指定配置文件路径"><a href="#在-package-json-指定配置文件路径" class="headerlink" title="在 package.json 指定配置文件路径"></a>在 package.json 指定配置文件路径</h3><pre><code>  &quot;scripts&quot;: &#123;
    &quot;build&quot;: &quot;webpack  --config  ./build/proud.config.js&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server  --config  ./build/dev.config.js&quot;
  &#125;,
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/16/vue4/" data-id="cl70ok8hp000044w9ffe20o0a" data-title="vue4" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vue3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/15/vue3/" class="article-date">
  <time class="dt-published" datetime="2022-08-15T15:43:09.000Z" itemprop="datePublished">2022-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/15/vue3/">vue3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h1><blockquote>
<p>##组件的基本介绍<br>注册组件的基本步骤  </p>
</blockquote>
<blockquote>
<ul>
<li>调用Vue.extend()方法 - 创建组件构造器  </li>
<li>调用Vue.component()方法 - 注册组件  </li>
<li>在Vue实例的作用范围内 - 使用组件</li>
</ul>
</blockquote>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    //使用组件
    &lt;my-cpm&gt;&lt;/my-cpm&gt;
&lt;/div&gt;

//创建组件构造器
const cpnC = Vue.extend(&#123;
    template: &#39;
    &lt;div&gt;
        &lt;h2&gt;标题&lt;/h2&gt;
        &lt;p&gt;模板&lt;/p&gt;
    &lt;/div&gt;&#39;
&#125;)

//注册组件
Vue.component(&#39;my-cpn&#39;, cpmC)

const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data:&#123;
        message: &#39;&#39;
    &#125;
&#125;)
</code></pre>
<blockquote>
<blockquote>
<h3 id="全局组件-x2F-局部组件"><a href="#全局组件-x2F-局部组件" class="headerlink" title="全局组件 &#x2F; 局部组件"></a>全局组件 &#x2F; 局部组件</h3><p>全局:上面案例  </p>
</blockquote>
</blockquote>
<blockquote>
<p>局部组件<br>    <div id="app"><br>        <my-cpm></my-cpm><br>    </div></p>
</blockquote>
<pre><code>const cpnC = Vue.extend(&#123;
    template: &#39;
    &lt;div&gt;
        &lt;h2&gt;标题&lt;/h2&gt;
        &lt;p&gt;模板&lt;/p&gt;
    &lt;/div&gt;&#39;
&#125;)

const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data:&#123;
        message: &#39;&#39;
    &#125;,
    components: &#123;
        cpn: cpnC
    &#125;
&#125;)
</code></pre>
<blockquote>
<blockquote>
<h3 id="父组件-x2F-子组件"><a href="#父组件-x2F-子组件" class="headerlink" title="父组件 &#x2F; 子组件"></a>父组件 &#x2F; 子组件</h3><blockquote>
<p>父子组件的错误用法: 以子标签的形式在Vue实例中使用  </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<ul>
<li>因为当子组件注册到父组件的components时, Vue会编译好父组件的模块</li>
<li>该模块的内容已经决定了父组件将要渲染的HTML (相当于父组件中已经有子组件中的内容了)</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<h3 id="语法塘"><a href="#语法塘" class="headerlink" title="语法塘"></a>语法塘</h3><p>Vue为了简化注册组件的过程, 提供了注册的语法塘, 省去了调用Vue.extend()的步骤. 而是可以直接使用一个对象来代替</p>
</blockquote>
</blockquote>
<pre><code>// 全局组件
Vue.component(&#39;xxx&#39;, &#123;
    template: &#39;
    &lt;div&gt;
        哈哈哈哈
    &lt;/div&gt;
    &#39;
&#125;)

// 内部会自动调用Vue.extend()


// 局部组件
const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        meassage: &#39;哈哈哈&#39;
    &#125;,
    components: &#123;
        &#39;cpn&#39;: &#123;
            template: &#39;
                &lt;div&gt;
                    哈哈哈哈
                &lt;/div&gt;
            &#39;
        &#125;
    &#125;
&#125;)
</code></pre>
<blockquote>
<h1 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h1><blockquote>
<h3 id="父子组件的通讯"><a href="#父子组件的通讯" class="headerlink" title="父子组件的通讯"></a>父子组件的通讯</h3><p>父组件通过props向子组件传递数据</p>
</blockquote>
</blockquote>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;cpm v-bind:cmovies=&quot;movies&quot; v-bind:cmessage=&quot;message&quot;&gt;&lt;/cpn&gt;
&lt;/div&gt;

&lt;template id=&quot;cpn&quot;&gt;
    &lt;div&gt;
        &lt;li v-for=&quot;item in cmovies&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;
        &lt;h2&gt;&#123;&#123;cmessage&#125;&#125;&lt;/h2&gt;
    &lt;/div&gt;
&lt;/template&gt;


const cpn = &#123;
    template: &#39;#cpn&#39;,
    // 把数组里的当变量来看了
    props: [&#39;cmovies&#39;, &#39;cmessage&#39;],
    data () &#123;
        return &#123;&#125;
    &#125;
&#125;

const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        meassage: &#39;哈哈哈&#39;,
        movies: [&#39;哈喽&#39;, &#39;嗨&#39;, &#39;哟哟&#39;]
    &#125;,
    components: &#123;
        cpn
    &#125;
&#125;)
</code></pre>
<blockquote>
<blockquote>
<p>子组件通过事件向父组件发送数据</p>
</blockquote>
</blockquote>
<pre><code>// 父组件模板
&lt;div id=&quot;app&quot;&gt;
    // 2.父组件监听一个事件
    // 不能写驼峰
    &lt;cpm @itemclick=&quot;cpnClick&quot;&gt;&lt;/cpn&gt;
&lt;/div&gt;

// 子组件模板
&lt;template id=&quot;cpn&quot;&gt;
    &lt;div&gt;
        &lt;button v-for=&quot;item in categories&quot; 
                @click=&quot;btnClick(item)&quot;&gt;
            &#123;&#123;item.name&#125;&#125;
        &lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;


// 子组件
const cpn = &#123;
    template: &#39;#cpn&#39;,
    data() &#123;
        return &#123;
            categories: [
                &#123;id: &#39;aaaa&#39;, name: &#39;热门推荐&#39;&#125;,
                &#123;id: &#39;bbbb&#39;, name: &#39;手机数码&#39;&#125;,
                &#123;id: &#39;cccc&#39;, name: &#39;家用家电&#39;&#125;,
                &#123;id: &#39;dddd&#39;, name: &#39;电脑办公&#39;&#125;,
            ]
        &#125;
    &#125;,
    methods: &#123;
        btnClick(item) &#123;
            // 要把item传给父组件
            // 1. 发送一个事件 (自定义事件)
            // 会把item当成默认的传到父组件去
            this.$emit(&#39;itemclick&#39;, item)
        ]
    &#125;
&#125;

// 父组件
const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        meassage: &#39;哈哈哈&#39;
    &#125;,
    components: &#123;
        cpn
    &#125;,
    methods: &#123;
        // 3. 父组件监听的事件 
        cpnClick(item) &#123;
            console.log(&#39;成功了&#39;, item);
        &#125;
    &#125;
&#125;)
</code></pre>
<blockquote>
<blockquote>
<h3 id="父子组件的访问方式"><a href="#父子组件的访问方式" class="headerlink" title="父子组件的访问方式"></a>父子组件的访问方式</h3><h3 id="父组件访问子组件"><a href="#父组件访问子组件" class="headerlink" title="父组件访问子组件"></a>父组件访问子组件</h3><ul>
<li>$children: 拿所有子组件</li>
<li>$refs: 拿指定的子组件</li>
</ul>
</blockquote>
</blockquote>
<pre><code>// this.$children是一个数组类型, 它包含所有子组件对象  
// 通过遍历, 取出所有子组件的message状态  

&lt;div id=&quot;app&quot;&gt;
    &lt;cpm&gt;&lt;/cpn&gt;
    &lt;cpm&gt;&lt;/cpn&gt;
    // 使用$refs的时候, 在想要访问的子组件上添加ref属性
    &lt;cpm ref=&quot;aaa&quot;&gt;&lt;/cpn&gt;
    &lt;buttun @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;
&lt;/div&gt;

&lt;template id=&quot;cpn&quot;&gt;
    &lt;div&gt;
        我是子组件
    &lt;/div&gt;
&lt;/template&gt;

const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        meassage: &#39;哈哈哈&#39;
    &#125;,
    methods: &#123;
        btnClick() &#123;
            cosole.log(this.$children);
            // $children 的使用方法, 一般用的少, 下标不固定
            // this.$children[0].showMessage();
            // this.$children[0].name;
            
            //for (let c of this.$children) &#123;
            //    console.log(c.name); // 我是子组件的name
            //    c.showMessage(); // showMessage
            //&#125;
            
            // $refs 的使用方法 =&gt; 对象类型, 默认是一个空的对象
            console.log(this.$refs.aaa.name); // 我是子组件的name
        &#125;
    &#125;
    components: &#123;
        cpn: &#123;
            template: &quot;#cpn&quot;,
            data() &#123;
                return &#123;
                    name: &#39;我是子组件的name&#39;
                &#125;
            &#125;,
            methods: &#123;
                showMessage() &#123;
                    cosole.log(&#39;showMessage&#39;);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;)
</code></pre>
<blockquote>
<blockquote>
<h3 id="子组件访问父组件"><a href="#子组件访问父组件" class="headerlink" title="子组件访问父组件"></a>子组件访问父组件</h3><ul>
<li>$parent: 上一级父组件</li>
<li>$root: 根组件</li>
</ul>
</blockquote>
</blockquote>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;cpm&gt;&lt;/cpn&gt;
&lt;/div&gt;

&lt;template id=&quot;cpn&quot;&gt;
    &lt;div&gt;
        &lt;ccpn&gt;&lt;/ccpn&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;template id=&quot;ccpn&quot;&gt;
    &lt;div&gt;
        &lt;h2&gt;我是子组件&lt;/h2&gt;
        &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        meassage: &#39;哈哈哈&#39;
    &#125;,

    components: &#123;
        cpn: &#123;
            template: &quot;#cpn&quot;,
            data() &#123;
               return &#123;
                   name: &#39;我是cpn的name&#39;
               &#125; 
            &#125;,
            conmponents: &#123;
                ccpn: &#123;
                    template: &#39;#ccpn&#39;,
                    btnClick() &#123;
                        // 1. 访问父组件$parent
                        // 不建议这么写, 一层套一层 复用性太差
                        console.log(this.$parent);  
                        console.log(this.$parent.name);  // 我是cpn的name
                        
                        // 2. 访问根组件 $root
                        console.log(this.$root.meassage);   // 哈哈哈
                    &#125; 
                &#125;
            &#125;
        &#125;
    &#125;
&#125;)
</code></pre>
<h1 id="跨级组件通信之provide-x2F-inject"><a href="#跨级组件通信之provide-x2F-inject" class="headerlink" title="跨级组件通信之provide&#x2F;inject"></a>跨级组件通信之provide&#x2F;inject</h1><p>provide选项允许我们指定我们想要提供给后代组件的数据&#x2F;方法。</p>
<pre><code>provide: function () &#123;
  return &#123;
    fun: this.fun, //方法
    name: &#39;Bob&#39;, // 数据
  &#125;
&#125;
</code></pre>
<p>然后在任何后代组件里，我们都可以使用inject选项来接收指定的我们想要添加在这个实例上的属性：</p>
<pre><code>//接受方法
inject: [&#39;fun&#39;]
//接受数据
inject:[&#39;name&#39;]
</code></pre>
<h1 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h1><p>作用:<br>组件的插槽是为了让我们封装的组件更加具有扩展性<br>让使用者可以决定组件内部的一些内容到底展示什么  </p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul>
<li>插槽的基本使用</li>
<li>插槽的默认值 button</li>
<li>如果有多个值同时放入到组件进行替换时, 一起作为替换元素</li>
</ul>
<p>d</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    // 使用默认值替换
    &lt;cpm&gt;&lt;/cpn&gt;
    // 插槽替换的元素
    &lt;cpm&gt;&lt;span&gt;这是替换的内容呀&lt;/span&gt;&lt;/cpn&gt;
    // 多个元素
    &lt;cpm&gt;
        &lt;div&gt;第一个元素&lt;/div&gt;
        &lt;p&gt;第二个元素&lt;/p&gt;
    &lt;/cpn&gt;
&lt;/div&gt;

&lt;template id=&quot;cpn&quot;&gt;
    &lt;div&gt;
        &lt;div&gt;这个是标题&lt;/div&gt;
        &lt;p&gt;这个是内容&lt;/p&gt;
        // 放入插槽
        &lt;slot&gt;默认值元素&lt;/slot&gt;
    &lt;/div&gt;
&lt;/template&gt;

const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        meassage: &#39;哈哈哈&#39;
    &#125;,
    components: &#123;
        cpn: &#123;
            template: &#39;#cpn&#39;
        &#125;
    &#125;
&#125;)
</code></pre>
<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>在多个插槽的情况下, 替换制定插槽的内容</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;cpm&gt;&lt;/cpn&gt;
    &lt;cpm&gt;&lt;button slot=&quot;left&quot;&gt;返回&lt;/button&gt;&lt;/cpn&gt;
    &lt;cpm&gt;&lt;span slot=&quot;center&quot;&gt;中间标题&lt;/span&gt;&lt;/cpn&gt;
&lt;/div&gt;

&lt;template id=&quot;cpn&quot;&gt;
    &lt;div&gt;
        &lt;slot name=&quot;left&quot;&gt;&lt;span&gt;左边&lt;/span&gt;&lt;/slot&gt;
        &lt;slot name=&quot;center&quot;&gt;&lt;span&gt;中间&lt;/span&gt;&lt;/slot&gt;
        &lt;slot name=&quot;right&quot;&gt;&lt;span&gt;右边&lt;/span&gt;&lt;/slot&gt;
    &lt;/div&gt;
&lt;/template&gt;

const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        meassage: &#39;哈哈哈&#39;
    &#125;,
    components: &#123;
        cpn: &#123;
            template: &#39;#cpn&#39;
        &#125;
    &#125;
&#125;)
</code></pre>
<h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><p>父组件模板所有的东西都在父级作用域内编译, 子组件模板的所有东西会在子级作用域内编译</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;cpm v-show=&quot;isShow&quot;&gt;我是一&lt;/cpn&gt; // true
&lt;/div&gt;

&lt;template id=&quot;cpn&quot;&gt;
    &lt;div&gt;
        &lt;p v-show=&quot;isShow&quot;&gt;我是二&lt;/p&gt; // false
    &lt;/div&gt;
&lt;/template&gt;

const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        isShow: true // Vue实例中的属性
    &#125;,
    components: &#123;
        cpn: &#123;
            template: &#39;#cpn&#39;,
            data() &#123;
                return &#123;
                     isShow: false // 子组件中的属性
                &#125;
            &#125;
        &#125;
    &#125;
&#125;)
</code></pre>
<h2 id="作用域插槽使用"><a href="#作用域插槽使用" class="headerlink" title="作用域插槽使用"></a>作用域插槽使用</h2><p>父组件替换插槽的标签, 但是内容由子组件来提供</p>
<pre><code>需求: 
1. 子组件中包括一组数据, num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;]
2. 需要在多个界面展示 
   某些界面是以水平方向展示
   某些界面是以列表形式展示
   某些界面直接展示一个数组 
3. 内容在子组件, 希望父组件告诉我们如何展示, 怎么办?
   利用slot作用域插槽就行了
   
&lt;div id=&quot;app&quot;&gt;
    &lt;cpm&gt;&lt;/cpn&gt; 
    &lt;cpm&gt;
        // 2. 获取子组件中的num
        &lt;template slot-scope=&quot;slot&quot;&gt;
            // 根据之前的起名来取  如 slot.aaa
            &lt;span  v-for=&quot;item in slot.data&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;
        &lt;/template&gt;
    &lt;/cpn&gt; 
    &lt;cpm&gt;&lt;/cpn&gt; 
&lt;/div&gt;

&lt;template id=&quot;cpn&quot;&gt;
    &lt;div&gt;
        // 1. slot定义  &#39;data&#39;可以随便起名 如 :aaa=&quot;num&quot;
        &lt;slot :data=&quot;num&quot;&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;item in num&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/slot&gt;
    &lt;/div&gt;
&lt;/template&gt;

const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        message: &#39;哈哈哈&#39;
    &#125;,
    components: &#123;
        cpn: &#123;
            template: &#39;#cpn&#39;,
            data() &#123;
                return &#123;
                    num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;]
                &#125;
            &#125;
        &#125;
    &#125;
&#125;)
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/15/vue3/" data-id="cl6uz06xd0002xow94rbya8hc" data-title="vue3" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="vue-vue2" class="h-entry article article-type-vue" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/14/vue2/" class="article-date">
  <time class="dt-published" datetime="2022-08-14T15:30:13.000Z" itemprop="datePublished">2022-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/14/vue2/">vue2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<h1 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h1><p>含义: 动态的给value赋值<br>1 在前面的value中的值, 都是在定义input的时候直接给定的<br>2 但真实开发中, input的值可能是从网络获取或定义在data中的<br>3 可以通过v-bind:value动态的给value绑定值  </p>
</blockquote>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;label v-for=&quot;item in nums&quot; :for=&quot;item&quot;&gt;
        &lt;inout type=&quot;checkbox&quot; value=&quot;item&quot; :id=&quot;item&quot; v-model=&quot;hobbies&quot;&gt;&#123;&#123;item&#125;&#125;
    &lt;/label&gt;
    &lt;h2&gt;您的爱好是: &#123;&#123;hobbies&#125;&#125;&lt;/h2&gt;
&lt;/div&gt;

cosnt app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        hobbies: [],
        nums: [&#39;篮球&#39;, &#39;足球&#39;, &#39;羽毛球&#39;]
    &#125;
&#125;)
</code></pre>
<blockquote>
<h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1></blockquote>
<blockquote>
<blockquote>
<h3 id="lazy修饰符"><a href="#lazy修饰符" class="headerlink" title="lazy修饰符"></a>lazy修饰符</h3></blockquote>
</blockquote>
<ul>
<li>前景: v-model默认是在input事件中实时同步输入框的数据的 (容易同步的过于频繁 )</li>
<li>作用: 可以让数据只有在失去焦点或回车时才会更新</li>
</ul>
<p><code>&lt;input type=&quot;text&quot; v-model.lazy=&quot;输入&quot;&gt;</code></p>
<blockquote>
<blockquote>
<h3 id="number修饰符"><a href="#number修饰符" class="headerlink" title="number修饰符"></a>number修饰符</h3></blockquote>
</blockquote>
<ul>
<li>前景: 默认情况下, 在输入框中无论输入字母还是数字, 都会被当做字符串类型进行处理</li>
<li>作用: 当做数字类型进行处理<blockquote>
<blockquote>
<h3 id="trim修饰符"><a href="#trim修饰符" class="headerlink" title="trim修饰符"></a>trim修饰符</h3></blockquote>
</blockquote>
</li>
<li>前景: 输入的内容首位容易有空格</li>
<li>作用: 可以过滤掉内容左右两边的空格</li>
</ul>
<blockquote>
<h1 id="检测数组更新"><a href="#检测数组更新" class="headerlink" title="检测数组更新"></a>检测数组更新</h1><p>Vue是响应式, 所以当数据发生变化时, Vue会自动检测数据变化, 视图会发生对应的更新.<br>Vue中观察数据编译的方法 – 用它们改变数组会触发视觉更新</p>
</blockquote>
<table>
<thead>
<tr>
<th>数组响应式方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>push()</td>
<td>在数组中最后增加元素</td>
</tr>
<tr>
<td>pop()</td>
<td>删除数组中最后一个元素</td>
</tr>
<tr>
<td>shift()</td>
<td>删除数组中的第一个元素</td>
</tr>
<tr>
<td>unshift()</td>
<td>在数组最前面添加元素</td>
</tr>
<tr>
<td>splice()</td>
<td>删除 &#x2F; 插入 &#x2F; 替换元素</td>
</tr>
</tbody></table>
<blockquote>
<h1 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h1><p>使用: 需要将多个数据结合起来进行显示的时候</p>
</blockquote>
<pre><code>&lt;div id=&#39;app&#39;&gt;

 // 使用拼接的方法 -- 语法太过繁琐
 &lt;h2&gt;&#123;&#123;firstName + '' + lastName&#125;&#125;&lt;/h2&gt;
 &lt;h2&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;&lt;/h2&gt;
 
 // 使用方法
 &lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;
 
 // 使用计算属性
 &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;
&lt;/div&gt;


const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data:&#123;
        firstName: &#39;li&#39;,
        lastName: &#39;er&#39;
    &#125;,
    // 计算属性
    computed: &#123;
        fullName: function () &#123;
            reture this.firstName + &#39;&#39; + this.lastName
        &#125;
    &#125;,
    // 方法
    methods: &#123;
        getFullName () &#123;
            reture this.firstName + &#39;&#39; + this.lastName
        &#125;
    &#125;
&#125;)
</code></pre>
<blockquote>
<blockquote>
<h3 id="计算属性setter和getter"><a href="#计算属性setter和getter" class="headerlink" title="计算属性setter和getter"></a>计算属性setter和getter</h3></blockquote>
</blockquote>
<pre><code>&lt;div id=&#39;app&#39;&gt;
 &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;
&lt;/div&gt;


const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data:&#123;
        firstName: &#39;li&#39;,
        lastName: &#39;er&#39;
    &#125;,
    // 计算属性
    computed: &#123;
        fullName: &#123;
            // 一般没有set方法 
            set: function (value) &#123;
                
            &#125;,
            // 只读属性
            get: function () &#123;
                reture this.firstName + &#39;&#39; + this.lastName
            &#125;
        &#125;
    &#125;
&#125;)
</code></pre>
<blockquote>
<blockquote>
<p>computed &#x2F; methods区别<br>多次使用的时候  </p>
</blockquote>
<blockquote>
<ul>
<li>methods: 每次都会调用</li>
<li>computed: 计算机会缓存, 不变的情况下只调用一次</li>
</ul>
</blockquote>
</blockquote>
<h1 id="fulters过滤器"><a href="#fulters过滤器" class="headerlink" title="fulters过滤器"></a>fulters过滤器</h1><pre><code>&lt;div id=&#39;app&#39;&gt;
 &lt;h2 &#123;&#123;aaa | showA&#125;&#125;&gt;&lt;/h2&gt;
&lt;/div&gt;


const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data:&#123;
        aaa: &#39;li&#39;
    &#125;,
    // 过滤器
    fulters: &#123;
        showA (value) &#123;
        return;
    &#125;
&#125;)
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/14/vue2/" data-id="cl6uz06xe0003xow96yq84imd" data-title="vue2" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis与springboot" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/13/redis%E4%B8%8Espringboot/" class="article-date">
  <time class="dt-published" datetime="2022-08-13T15:33:57.000Z" itemprop="datePublished">2022-08-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/13/redis%E4%B8%8Espringboot/">redis与springboot</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h1><pre><code>&lt;dependencies&gt;
    &lt;!--集成redis--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;version&gt;2.1.7.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--序列化--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
        &lt;version&gt;1.2.54&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--lombok,自动生成set、get等方法--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.10&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
</code></pre>
<h1 id="yml配置文件"><a href="#yml配置文件" class="headerlink" title="yml配置文件"></a>yml配置文件</h1><pre><code>server:
  port: 10001

spring:
  redis:
    host: 127.0.0.1
    port: 6379
</code></pre>
<h1 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h1><pre><code>import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.RedisTemplate;

@SpringBootTest
public class testRedis &#123;

    @Autowired(required = false)
    private RedisTemplate redisTemplate;

    @Test
    void getName()&#123;
        redisTemplate.opsForValue().set(&quot;name&quot;,&quot;dadadingdada!&quot;);
        System.out.println(redisTemplate.opsForValue().get(&quot;name&quot;));
    &#125;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/13/redis%E4%B8%8Espringboot/" data-id="cl6uz06xd0001xow9d0k58ob0" data-title="redis与springboot" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/13/redis3/" class="article-date">
  <time class="dt-published" datetime="2022-08-12T16:06:25.000Z" itemprop="datePublished">2022-08-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/13/redis3/">redis3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/13/redis3/" data-id="cl6uz06x70000xow9534m54o9" data-title="redis3" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/12/redis2/" class="article-date">
  <time class="dt-published" datetime="2022-08-12T15:13:41.000Z" itemprop="datePublished">2022-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/12/redis2/">redis2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="2-2-2-list类型"><a href="#2-2-2-list类型" class="headerlink" title="2.2.2 list类型"></a>2.2.2 list类型</h2><p>lpush（左插入）、lrange（查询集合）、rpush（右插入）操作  </p>
<pre><code>#lpush
127.0.0.1:6379&gt; lpush list v1  #新增一个集合
(integer) 1
127.0.0.1:6379&gt; lpush list v2
(integer) 2
127.0.0.1:6379&gt; lpush list v3
(integer) 3  

#lrange
127.0.0.1:6379&gt; LRANGE list 0 -1  #查询list的所有元素值
1) &quot;v3&quot;
2) &quot;v2&quot;
3) &quot;v1&quot;
127.0.0.1:6379&gt; lpush list1 v1 v2 v3 v4 v5  #批量添加集合元素
(integer) 5
127.0.0.1:6379&gt; LRANGE list1 0 -1
1) &quot;v5&quot;
2) &quot;v4&quot;
3) &quot;v3&quot;
4) &quot;v2&quot;
5) &quot;v1&quot;

#rpush
127.0.0.1:6379&gt; LRANGE list 0 1  #指定查询列表中的元素，从下标零开始，1结束，两个元素
1) &quot;v3&quot;
2) &quot;v2&quot;
127.0.0.1:6379&gt; LRANGE list 0 0  #指定查询列表中的唯一元素
1) &quot;v3&quot;
127.0.0.1:6379&gt; rpush list rv0  #右插入，跟lpush相反，这里添加进去元素是在尾部！
(integer) 4
127.0.0.1:6379&gt; lrange list 0 -1  #查看集合所有元素
1) &quot;v3&quot;
2) &quot;v2&quot;
3) &quot;v1&quot;
4) &quot;rv0&quot;

每次都使用lpush，老的数据永远在后面，我们每次获取 0 0 位置的元素，相当于更新了
数据操作，但是数据记录还在。查询记录即可获取集合所有元素
</code></pre>
<p>lpop（左移除）、rpop（右移除）操作</p>
<pre><code>#lpop
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v5&quot;
2) &quot;v4&quot;
3) &quot;v3&quot;
4) &quot;v2&quot;
5) &quot;v1&quot;
127.0.0.1:6379&gt; lpop list  #从头部开始移除第一个元素
&quot;v5&quot;

#rpop
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v4&quot;
2) &quot;v3&quot;
3) &quot;v2&quot;
4) &quot;v1&quot;
127.0.0.1:6379&gt; rpop list
&quot;v1&quot;
127.0.0.1:6379&gt; LRANGE list 0 -1  #从尾部开始移除第一个元素
1) &quot;v4&quot;
2) &quot;v3&quot;
3) &quot;v2&quot;
</code></pre>
<p>lindex（查询指定下标元素）、llen（获取集合长度） 操作</p>
<pre><code>#lindex
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v4&quot;
2) &quot;v3&quot;
3) &quot;v2&quot;
127.0.0.1:6379&gt; lindex list 1  #获取指定下标位置集合的元素，下标从0开始计数
&quot;v3&quot;
127.0.0.1:6379&gt; lindex list 0  #相当于java中的indexof
&quot;v4&quot;

#llen
127.0.0.1:6379&gt; llen list  #获取指定集合的元素长度，相当于java中的length或者size
(integer) 3
</code></pre>
<p>lrem（根据value移除指定的值）</p>
<pre><code>127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v4&quot;
2) &quot;v3&quot;
3) &quot;v2&quot;
127.0.0.1:6379&gt; lrem list 1 v2  #移除集合list中的元素是v2的元素1个
(integer) 1
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v4&quot;
2) &quot;v3&quot;
127.0.0.1:6379&gt; lrem list 0 v3 #移除集合list中的元素是v2的元素1个,这里的0和1效果是一致的
(integer) 1
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v4&quot;
127.0.0.1:6379&gt; lpush list  v3 v2 v2 v2
(integer) 4
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v2&quot;
2) &quot;v2&quot;
3) &quot;v2&quot;
4) &quot;v3&quot;
5) &quot;v4&quot;
127.0.0.1:6379&gt; lrem list 3 v2  #移除集合list中元素为v2 的‘3’个，这里的参数数量，如果实际中集合元素数量不达标，不会报错，全部移除后返回成功移除后的数量值
(integer) 3
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v3&quot;
2) &quot;v4&quot;
</code></pre>
<p>ltrim（截取元素）、rpoplpush（移除指定集合中最后一个元素到一个新的集合中）操作</p>
<pre><code>#ltrim
127.0.0.1:6379&gt; lpush list v1 v2 v3 v4
(integer) 4
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v4&quot;
2) &quot;v3&quot;
3) &quot;v2&quot;
4) &quot;v1&quot;
127.0.0.1:6379&gt; ltrim list 1 2  #通过下标截取指定的长度，这个list已经被改变了，只剩下我们所指定截取后的元素
OK
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v3&quot;
2) &quot;v2&quot;

#rpoplpush
127.0.0.1:6379&gt; lpush list v1 v2 v3 v4 v5
(integer) 5
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v5&quot;
2) &quot;v4&quot;
3) &quot;v3&quot;
4) &quot;v2&quot;
5) &quot;v1&quot;
127.0.0.1:6379&gt; rpoplpush list newlist  #移除list集合中的最后一个元素到新的集合newlist中，返回值是移除的最后一个元素值
&quot;v1&quot;
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v5&quot;
2) &quot;v4&quot;
3) &quot;v3&quot;
4) &quot;v2&quot;
127.0.0.1:6379&gt; LRANGE newlist 0 -1  #确实存在该newlist集合并且有刚刚移除的元素，证明成功
1) &quot;v1&quot;
</code></pre>
<p>lset（更新）、linsert操作</p>
<pre><code>#lset
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v5&quot;
2) &quot;v4&quot;
3) &quot;v3&quot;
4) &quot;v2&quot;
127.0.0.1:6379&gt; 
127.0.0.1:6379&gt; lset list 1 newV5  #更新list集合中下标为‘1’的元素为‘newV5’
OK
127.0.0.1:6379&gt; LRANGE list 0 -1  #查看证明更新成功
1) &quot;v5&quot;
2) &quot;newV5&quot;
3) &quot;v3&quot;
4) &quot;v2&quot;
注意点：
127.0.0.1:6379&gt; lset list1 0 vvvv  #如果指定的‘集合’不存在，报错
(error) ERR no such key
127.0.0.1:6379&gt; lset list 8 vvv  #如果集合存在，但是指定的‘下标’不存在，报错

#linsert
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v5&quot;
2) &quot;newV5&quot;
3) &quot;v3&quot;
4) &quot;v2&quot;
127.0.0.1:6379&gt; LINSERT list after v3 insertv3  #在集合中的‘v3’元素 ‘(after)之后’ 加上一个元素
(integer) 5
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v5&quot;
2) &quot;newV5&quot;
3) &quot;v3&quot;
4) &quot;insertv3&quot;
5) &quot;v2&quot;
127.0.0.1:6379&gt; LINSERT list before v3 insertv3  #在集合中的‘v3’元素 ‘(before)之前’ 加上一个元素
(integer) 6
127.0.0.1:6379&gt; LRANGE list 0 -1
1) &quot;v5&quot;
2) &quot;newV5&quot;
3) &quot;insertv3&quot;
4) &quot;v3&quot;
5) &quot;insertv3&quot;
6) &quot;v2&quot;
</code></pre>
<p>小结：</p>
<p>实际上是一个链表，before Node after ， left，right 都可以插入值<br>如果key 不存在，创建新的链表<br>如果key存在，新增内容<br>如果移除了所有值，空链表，也代表不存在<br>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点<br>消息排队消息队列 （Lpush Rpop）， 栈（ Lpush Lpop）</p>
<h2 id="2-2-3-Set（集合）元素唯一不重复"><a href="#2-2-3-Set（集合）元素唯一不重复" class="headerlink" title="2.2.3 Set（集合）元素唯一不重复"></a>2.2.3 Set（集合）元素唯一不重复</h2><p>sadd（添加）、smembers（查看所有元素）、sismember（判断是否存在）、scard（查看长度）、srem（移除指定元素）操作</p>
<pre><code>#set中所有的元素都是唯一的不重复的！
127.0.0.1:6379&gt; sadd set1 test1 test2 test3 test4  #添加set集合（可批量可单个，写法一致）
(integer) 4
127.0.0.1:6379&gt; SMEMBERS set1  #查看set中所有元素
1) &quot;test1&quot;
2) &quot;test2&quot;
3) &quot;test3&quot;
4) &quot;test4&quot;
127.0.0.1:6379&gt; SISMEMBER set1 test2  #判断某个值在不在set中，在返回1
(integer) 1
127.0.0.1:6379&gt; SISMEMBER set1 test5  #不在返回0
(integer) 0
127.0.0.1:6379&gt; SCARD set1  #查看集合的长度，相当于size、length
(integer) 4
127.0.0.1:6379&gt; srem set1 test2  #移除set中指定的元素
(integer) 1
127.0.0.1:6379&gt; SMEMBERS set1  #移除成功
1) &quot;test1&quot;
2) &quot;test3&quot;
3) &quot;test4&quot;
</code></pre>
<p>srandmember（抽随机）操作</p>
<pre><code>127.0.0.1:6379&gt; sadd myset 1 2 3 4 5 6 7  #在set中添加7个元素
(integer) 7
127.0.0.1:6379&gt; SMEMBERS myset
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
5) &quot;5&quot;
6) &quot;6&quot;
7) &quot;7&quot;
127.0.0.1:6379&gt; SRANDMEMBER myset 1  #随机抽取myset中1个元素返回
1) &quot;4&quot;
127.0.0.1:6379&gt; SRANDMEMBER myset 1  #随机抽取myset中1个元素返回
1) &quot;1&quot;
127.0.0.1:6379&gt; SRANDMEMBER myset 1  #随机抽取myset中1个元素返回
1) &quot;5&quot;
127.0.0.1:6379&gt; SRANDMEMBER myset  #不填后参数，默认抽1个值，但是下面返回不会带序号值
&quot;3&quot;
127.0.0.1:6379&gt; SRANDMEMBER myset 3  #随机抽取myset中3个元素返回
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
127.0.0.1:6379&gt; SRANDMEMBER myset 3  #随机抽取myset中3个元素返回
1) &quot;6&quot;
2) &quot;3&quot;
3) &quot;5&quot;
</code></pre>
<p>spop（随机删除元素）、smove（移动指定元素到新的集合中）操作</p>
<pre><code>127.0.0.1:6379&gt; SMEMBERS myset
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
5) &quot;5&quot;
6) &quot;6&quot;
7) &quot;7&quot;
127.0.0.1:6379&gt; spop myset  #随机删除1个元素，不指定参数值即删除1个
&quot;2&quot;
127.0.0.1:6379&gt; spop myset 1  #随机删除1个元素
1) &quot;7&quot;
127.0.0.1:6379&gt; spop myset 2  #随机删除2个元素
1) &quot;3&quot;
2) &quot;5&quot;
127.0.0.1:6379&gt; SMEMBERS myset  #查询删除后的结果
1) &quot;1&quot;
2) &quot;4&quot;
3) &quot;6&quot;
127.0.0.1:6379&gt; smove myset myset2 1  #移动指定set中的指定元素到新的set中
(integer) 1
127.0.0.1:6379&gt; SMEMBERS myset  #查询原来的set集合
1) &quot;4&quot;
2) &quot;6&quot;
127.0.0.1:6379&gt; SMEMBERS myset2  #查询新的set集合，如果新的set存在，即往后加，如果不存在，则自动创建set并且加入进去
1) &quot;1&quot;
</code></pre>
<p>sdiff（差集）、sinter（交集）、sunion（并集）操作</p>
<pre><code>127.0.0.1:6379&gt; sadd myset1 1 2 3 4 5
(integer) 5
127.0.0.1:6379&gt; sadd myset2 3 4 5 6 7
(integer) 5
127.0.0.1:6379&gt; SMEMBERS myset1
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
5) &quot;5&quot;
127.0.0.1:6379&gt; SMEMBERS myset2
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;5&quot;
4) &quot;6&quot;
5) &quot;7&quot;
127.0.0.1:6379&gt; SDIFF myset1 myset2  #查询指定的set之间的差集，可以是多个set
1) &quot;1&quot;
2) &quot;2&quot;
127.0.0.1:6379&gt; SINTER myset1 myset2  #查询指定的set之间的交集，可以是多个set
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;5&quot;
127.0.0.1:6379&gt; sunion myset1 myset2  #查询指定的set之间的并集，可以是多个set
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
5) &quot;5&quot;
6) &quot;6&quot;
7) &quot;7&quot;
</code></pre>
<p>总结：可实现共同好友、共同关注等需求。</p>
<h2 id="2-2-4-Hash（哈希）"><a href="#2-2-4-Hash（哈希）" class="headerlink" title="2.2.4 Hash（哈希）"></a>2.2.4 Hash（哈希）</h2><p>hset（添加hash）、hget（查询）、hgetall（查询所有）、hdel（删除hash中指定的值）、hlen（获取hash的长度）、hexists（判断key是否存在）操作</p>
<pre><code>127.0.0.1:6379&gt; hset myhash key1 set1 key2 set2  #添加hash，可多个
(integer) 2
127.0.0.1:6379&gt; hget myhash key1  #获取hash中key是key1的值
&quot;set1&quot;
127.0.0.1:6379&gt; hget myhash key2 
&quot;set2&quot;
127.0.0.1:6379&gt; hgetall myhash  #获取hash中所有的值，包含key
1) &quot;key1&quot;
2) &quot;set1&quot;
3) &quot;key2&quot;
4) &quot;set2&quot;
127.0.0.1:6379&gt; hset myhash del test  #添加
(integer) 1
127.0.0.1:6379&gt; hgetall myhash
1) &quot;key1&quot;
2) &quot;set1&quot;
3) &quot;key2&quot;
4) &quot;set2&quot;
5) &quot;del&quot;
6) &quot;test&quot;
127.0.0.1:6379&gt; hdel myhash del key2  #删除指定hash中的key（可多个），key删除后对应的value也会被删除
(integer) 2
127.0.0.1:6379&gt; hgetall myhash
1) &quot;key1&quot;
2) &quot;set1&quot;
127.0.0.1:6379&gt; hlen myhash  #获取指定hash的长度，相当于length、size
(integer) 1
127.0.0.1:6379&gt; HEXISTS myhash name  #判断key是否存在于指定的hash，存在返回1
(integer) 1
127.0.0.1:6379&gt; HEXISTS myhash age  #判断key是否存在于指定的hash，不存在返回0
(integer) 0
</code></pre>
<p>hkeys（获取所有key）、hvals（获取所有value）、hincrby（给值加增量）、hsetnx（存在不添加）操作</p>
<pre><code>127.0.0.1:6379&gt; hset myhash k 1 kk 2
(integer) 2
127.0.0.1:6379&gt; hgetall myhash
1) &quot;key1&quot;
2) &quot;set1&quot;
3) &quot;k&quot;
4) &quot;1&quot;
5) &quot;kk&quot;
6) &quot;2&quot;
127.0.0.1:6379&gt; hkeys myhash  #获取指定hash中的所有key
1) &quot;key1&quot;
2) &quot;k&quot;
3) &quot;kk&quot;
127.0.0.1:6379&gt; hvals myhash   #获取指定hash中的所有value
1) &quot;set1&quot;
2) &quot;1&quot;
3) &quot;2&quot;
127.0.0.1:6379&gt; hincrby myhash age 2  #让hash中age的value指定+2(自增)
(integer) 3
127.0.0.1:6379&gt; hincrby myhash age -1  #让hash中age的value指定-1(自减)
(integer) 2
127.0.0.1:6379&gt; hsetnx myhash nokey novalue  #添加不存在就新增返回新增成功的数量（只能单个增加）
(integer) 1 
127.0.0.1:6379&gt; hsetnx myhash name miaotiao  #添加存在则失败返回0
(integer) 0
127.0.0.1:6379&gt; hgetall myhash
1) &quot;key1&quot;
2) &quot;set1&quot;
3) &quot;k&quot;
4) &quot;2&quot;
5) &quot;kk&quot;
6) &quot;2&quot;
7) &quot;nokey&quot;
8) &quot;novalue&quot;
</code></pre>
<p>总结：比String更加适合存对象</p>
<h2 id="2-2-5-zSet（有序集合）"><a href="#2-2-5-zSet（有序集合）" class="headerlink" title="2.2.5 zSet（有序集合）"></a>2.2.5 zSet（有序集合）</h2><p>zadd（添加）、zrange（查询）、zrangebyscore（排序小-大）、zrevrange（排序大-小）、zrangebyscore withscores（查询所有值包含key）操作</p>
<pre><code>127.0.0.1:6379&gt; zadd myzset 1 one 2 two 3 three  #添加zset值，可多个
(integer) 3
127.0.0.1:6379&gt; ZRANGE myzset 0 -1  #查询所有的值
1) &quot;one&quot;
2) &quot;two&quot;
3) &quot;three&quot;
#-inf 负无穷  +inf 正无穷
127.0.0.1:6379&gt; ZRANGEBYSCORE myzset -inf +inf  #将zset的值根据key来从小到大排序并输出
1) &quot;one&quot;
2) &quot;two&quot;
3) &quot;three&quot;
127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 0 1  #只查询key&lt;=1的值并且排序从小到大
1) &quot;one&quot;
127.0.0.1:6379&gt; ZREVRANGE myzset 1 -1  #从大到小排序输出
1) &quot;two&quot;
2) &quot;one&quot;
127.0.0.1:6379&gt; ZRANGEBYSCORE myzset -inf +inf withscores  #查询指定zset的所有值，包含序号的值
1) &quot;one&quot;
2) &quot;1&quot;
3) &quot;two&quot;
4) &quot;2&quot;
5) &quot;three&quot;
6) &quot;3&quot;
</code></pre>
<p>zrem（移除元素）、zcard（查看元素个数）、zcount（查询指定区间内的元素个数）操作</p>
<pre><code>127.0.0.1:6379&gt; zadd myset 1 v1 2 v2 3 v3 4 v4
(integer) 4
127.0.0.1:6379&gt; ZRANGE myset 0 -1
1) &quot;v1&quot;
2) &quot;v2&quot;
3) &quot;v3&quot;
4) &quot;v4&quot;
127.0.0.1:6379&gt; zrem myset v3  #移除指定的元素，可多个
(integer) 1
127.0.0.1:6379&gt; ZRANGE myset 0 -1
1) &quot;v1&quot;
2) &quot;v2&quot;
3) &quot;v4&quot;
127.0.0.1:6379&gt; zcard myset  #查看zset的元素个数，相当于长度，size。
(integer) 3
127.0.0.1:6379&gt; zcount myset 0 100  #查询指定区间内的元素个数
(integer) 3
127.0.0.1:6379&gt; zcount myset 0 2  #查询指定区间内的元素个数
(integer) 2
</code></pre>
<p>总结：成绩表排序，工资表排序，年龄排序等需求可以用zset来实现！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/12/redis2/" data-id="cl6qnrrw50000cgw9axgres0a" data-title="redis2" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/10/redis1/" class="article-date">
  <time class="dt-published" datetime="2022-08-10T11:14:54.000Z" itemprop="datePublished">2022-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/10/redis1/">redis1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-redis服务安装"><a href="#1-redis服务安装" class="headerlink" title="1.redis服务安装"></a>1.redis服务安装</h1><p>自己上github找<br>解压后cmd进入安装根目录<br><code>redis-server redis.windows.conf</code>启动服务<br>之后双击redis-cli.exe  </p>
<p>设置开启启动redis服务<br>进入根目录输入<br><code>redis-server --service-install redis.windows-service.conf --loglevel verbose</code>  </p>
<p>redis可视化工具RedisDesktopManager</p>
<h1 id="2-redis入门"><a href="#2-redis入门" class="headerlink" title="2.redis入门"></a>2.redis入门</h1><p>Redis（Remote Dictionary Server )，即远程字典服务<br>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。<br>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><p>基本操作</p>
<pre><code>127.0.0.1:6379&gt; ping  #查看当前连接是否正常，正常返回PONG
PONG
127.0.0.1:6379&gt; clear  #清空当前控制台（为了更好的看到下面输入的命令）
127.0.0.1:6379&gt; keys *  #查看当前库里所有的key
1) &quot;db&quot;
127.0.0.1:6379&gt; FLUSHALL  #清空所有库的内容
OK
127.0.0.1:6379&gt; keys * 
(empty array)
127.0.0.1:6379&gt; set name test  #添加一个key为‘name’ value为‘test’的数据
OK
127.0.0.1:6379&gt; get name  #查询key为‘name’的value值
&quot;test&quot;
127.0.0.1:6379&gt; keys *
1) &quot;name&quot;
127.0.0.1:6379&gt; set name1 test2
OK
127.0.0.1:6379&gt; get name1
&quot;test2&quot;
127.0.0.1:6379&gt; keys *  #查看当前库里所有的key
1) &quot;name1&quot;
2) &quot;name&quot;
127.0.0.1:6379&gt; EXISTS name  #判断当前key是否存在
(integer) 1
127.0.0.1:6379&gt; move name 1  #移除当前库1的key为‘name’的数据
(integer) 1
127.0.0.1:6379&gt; keys *
1) &quot;name1&quot;
127.0.0.1:6379&gt; FLUSHALL  #再次清空所有库的内容
OK

多加几条数据 下面测试设置key的过期时间
127.0.0.1:6379&gt; set name test
OK
127.0.0.1:6379&gt; set name1 test1
OK
127.0.0.1:6379&gt; set name2 test2
OK
127.0.0.1:6379&gt; EXPIRE name 15  #设置key为’name‘的数据过期时间为15秒 单位seconds
(integer) 1
127.0.0.1:6379&gt; ttl name  #查看当前key为’name‘的剩余生命周期时间
(integer) 13
127.0.0.1:6379&gt; ttl name
(integer) 12
127.0.0.1:6379&gt; ttl name
(integer) 11
127.0.0.1:6379&gt; ttl name
(integer) 8
127.0.0.1:6379&gt; ttl name
(integer) 6
127.0.0.1:6379&gt; ttl name
(integer) 3
127.0.0.1:6379&gt; ttl name
(integer) 2
127.0.0.1:6379&gt; ttl name
(integer) 1
127.0.0.1:6379&gt; ttl name
(integer) 0
127.0.0.1:6379&gt; ttl name  #如若返回-2，证明key已过期
(integer) -2
127.0.0.1:6379&gt; get name    #再次查询即为空
(nil)
127.0.0.1:6379&gt; type name1
string
127.0.0.1:6379&gt; 
</code></pre>
<h2 id="2-2数据类型"><a href="#2-2数据类型" class="headerlink" title="2.2数据类型"></a>2.2数据类型</h2><h3 id="2-2-1-string"><a href="#2-2-1-string" class="headerlink" title="2.2.1 string"></a>2.2.1 string</h3><p>添加、查询、追加、获取长度、判断存在的操作</p>
<pre><code>127.0.0.1:6379&gt; set name test  #插入一个key为‘name’值为‘test’的数据
OK
127.0.0.1:6379&gt; get name  #获取key为‘name’的数据
&quot;test&quot;
127.0.0.1:6379&gt; get key1
&quot;hello world!&quot;
127.0.0.1:6379&gt; keys *  #查看当前库的所有数据
1) &quot;name&quot;
127.0.0.1:6379&gt; EXISTS name  #判断key为‘name’的数据存在不存在，存在返回1
(integer) 1
127.0.0.1:6379&gt; EXISTS name1  #不存在返回0
(integer) 0
127.0.0.1:6379&gt; APPEND name1 test1  #追加到key为‘name’的数据后拼接值为‘test1’，如果key存在类似于java中字符串‘+’，不存在则新增一个，类似于Redis中的set name1 test1 ，并且返回该数据的总长度
(integer) 9
127.0.0.1:6379&gt; get name1
&quot;test1&quot;
127.0.0.1:6379&gt; STRLEN name1  #查看key为‘name1’的字符串长度
(integer) 9
127.0.0.1:6379&gt; APPEND name1 ,test2  #追加，key存在的话，拼接‘+’，返回总长度
(integer) 19
127.0.0.1:6379&gt; STRLEN name1
(integer) 19
127.0.0.1:6379&gt; get name1
&quot;test1,test2&quot;
127.0.0.1:6379&gt; set key1 &quot;hello world!&quot;  #注意点：插入的数据中如果有空格的数据，请用“”双引号，否则会报错！
OK
127.0.0.1:6379&gt; set key1 hello world!  #报错，因为在Redis中空格就是分隔符，相当于该参数已结束
(error) ERR syntax error
127.0.0.1:6379&gt; set key1 hello,world!  #逗号是可以的
OK
</code></pre>
<p>自增、自减</p>
<pre><code>127.0.0.1:6379&gt; set num 0  #插入一个初始值为0的数据
OK
127.0.0.1:6379&gt; get num
&quot;0&quot;
127.0.0.1:6379&gt; incr num  #指定key为‘num’的数据自增1，返回结果  相当于java中 i++
(integer) 1
127.0.0.1:6379&gt; get num  #一般用来做文章浏览量、点赞数、收藏数等功能
&quot;1&quot;
127.0.0.1:6379&gt; incr num
(integer) 2
127.0.0.1:6379&gt; incr num
(integer) 3
127.0.0.1:6379&gt; get num
&quot;3&quot;
127.0.0.1:6379&gt; decr num  #指定key为‘num’的数据自减1，返回结果  相当于java中 i--
(integer) 2
127.0.0.1:6379&gt; decr num
(integer) 1
127.0.0.1:6379&gt; decr num
(integer) 0
127.0.0.1:6379&gt; decr num  #可以一直减为负数~
(integer) -1
127.0.0.1:6379&gt; decr num  #一般用来做文章取消点赞、取消收藏等功能
(integer) -2
127.0.0.1:6379&gt; decr num
(integer) -3
127.0.0.1:6379&gt; INCRBY num 10  #后面跟上by  指定key为‘num’的数据自增‘参数（10）’，返回结果
(integer) 7
127.0.0.1:6379&gt; INCRBY num 10
(integer) 17
127.0.0.1:6379&gt; DECRBY num 3  #后面跟上by  指定key为‘num’的数据自减‘参数（3）’，返回结果
(integer) 14
127.0.0.1:6379&gt; DECRBY num 3
(integer) 11
</code></pre>
<p>截取、替换字符串</p>
<pre><code>#截取
127.0.0.1:6379&gt; set key1 &quot;hello world!&quot;
OK
127.0.0.1:6379&gt; get key1
&quot;hello world!&quot;
127.0.0.1:6379&gt; GETRANGE key1 0 4  #截取字符串，相当于java中的subString，下标从0开始，不会改变原有数据
&quot;hello&quot;
127.0.0.1:6379&gt; get key1
&quot;hello world!&quot;
127.0.0.1:6379&gt; GETRANGE key1 0 -1  #0至-1相当于 get key1，效果一致，获取整条数据
&quot;hello world!&quot;
#替换
127.0.0.1:6379&gt; set key2 &quot;hello,,,world!&quot;
OK
127.0.0.1:6379&gt; get key2
&quot;hello,,,world!&quot;
127.0.0.1:6379&gt; SETRANGE key2 5 888  #此语句跟java中replace有点类似，下标也是从0开始，但是有区别：java中是指定替换字符，Redis中是从指定位置开始替换，替换的数据根据你所需替换的长度一致，返回值是替换后的长度
(integer) 14
127.0.0.1:6379&gt; get key2
&quot;hello888world!&quot;
127.0.0.1:6379&gt; SETRANGE key2 5 67  #该处只替换了两位
(integer) 14
127.0.0.1:6379&gt; get key2
&quot;hello678world!&quot;
</code></pre>
<p>设置过期时间、不存在设置</p>
<pre><code>#设置过期时间，跟Expire的区别是前者设置已存在的key的过期时间，而setex是在创建的时候设置过期时间
127.0.0.1:6379&gt; setex name1 15  tset  #新建一个key为‘name1’，值为‘test’，过期时间为15秒的字符串数据
OK
127.0.0.1:6379&gt; ttl name1  #查看key为‘name1’的key的过期时间
(integer) 6
127.0.0.1:6379&gt; ttl name1
(integer) 5
127.0.0.1:6379&gt; ttl name1
(integer) 3
127.0.0.1:6379&gt; ttl name1
(integer) 1
127.0.0.1:6379&gt; ttl name1
(integer) 0
127.0.0.1:6379&gt; ttl name1  #返回为-2时证明该key已过期，即不存在
(integer) -2
#不存在设置
127.0.0.1:6379&gt; setnx name2 dingdada2  #如果key为‘name2’不存在，新增数据，返回值1证明成功
(integer) 1
127.0.0.1:6379&gt; get name2
&quot;test2&quot;
127.0.0.1:6379&gt; keys *
1) &quot;name2&quot;
127.0.0.1:6379&gt; setnx name2 &quot;dingdada3&quot;  #如果key为‘name2’的已存在，设置失败，返回值0，也就是说这个跟set的区别是：set会替换原有的值，而setnx不会，存在即不设置，确保了数据误操作~
(integer) 0
127.0.0.1:6379&gt; get name2
&quot;test2&quot;
</code></pre>
<p>mset、mget</p>
<pre><code>127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3  #插入多条数据
OK
127.0.0.1:6379&gt; keys *  #查询所有数据
1) &quot;k2&quot;
2) &quot;k3&quot;
3) &quot;k1&quot;
127.0.0.1:6379&gt; mget k1 k2 k3  #查询key为‘k1’，‘k2’，‘k3’的数据
1) &quot;v1&quot;
2) &quot;v2&quot;
3) &quot;v3&quot;
127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4  #msetnx是一个原子性的操作，在一定程度上保证了事务！要么都成功，要么都失败！相当于if中的条件&amp;&amp;（与）
(integer) 0
127.0.0.1:6379&gt; keys *
1) &quot;k2&quot;
2) &quot;k3&quot;
3) &quot;k1&quot;
127.0.0.1:6379&gt; MSETNX k5 v5 k4 v4  #全部成功
(integer) 1
127.0.0.1:6379&gt; keys *
1) &quot;k2&quot;
2) &quot;k4&quot;	
3) &quot;k3&quot;
4) &quot;k5&quot;
5) &quot;k1&quot;
</code></pre>
<p>添加获取对象、getset操作</p>
<pre><code>#这里其实本质上还是字符串，但是我们讲其key巧妙的设计了一下。
##mset student:1:name  student 相当于类名，1 相当于id，name 相当于属性
#如果所需数据全部这样设计，那么我们在java的业务代码中，就不需要关注太多的key
#只需要找到student类，下面哪个id，需要哪个属性即可，减少了代码的繁琐，在一定程度上可以理解为这个一个类的对象！
127.0.0.1:6379&gt; mset student:1:name dingdada student:1:age 22  #新增一个key为‘student:1:name’，value为‘dingdada ’。。等数据
OK
127.0.0.1:6379&gt; keys *  #查看所有的key
1) &quot;student:1:age&quot;
2) &quot;student:1:name&quot;
127.0.0.1:6379&gt; mget student:1:age student:1:name  #获取数据
1) &quot;22&quot;
2) &quot;dingdada&quot;

##getset操作
127.0.0.1:6379&gt; getset name1 dingdada1  #先get再set，先获取key，如果没有，set值进去，返回的是get的值
(nil)
127.0.0.1:6379&gt; get name1
&quot;dingdada1&quot;
127.0.0.1:6379&gt; getset name1 dingdada2  ##先获取key，如果有，set（替换）最新的值进去，返回的是get的值
&quot;dingdada1&quot;
127.0.0.1:6379&gt; get name1  #替换成功
&quot;dingdada2&quot;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/10/redis1/" data-id="cl6on3sz70001ukw9c9j6fdfa" data-title="redis1" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vue1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/10/vue1/" class="article-date">
  <time class="dt-published" datetime="2022-08-10T10:23:17.000Z" itemprop="datePublished">2022-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/10/vue1/">vue1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="vue概念"><a href="#vue概念" class="headerlink" title="vue概念"></a>vue概念</h1><p>Vue是一个渐进式的框架<br>渐进式意味着你可以将Vue作为你应用的一部分嵌套其中<br>Vue的核心库以及其生态系统<br>Core + Vue-router + Vuex  </p>
<h1 id="vue语法"><a href="#vue语法" class="headerlink" title="vue语法"></a>vue语法</h1><h3 id="1-综合"><a href="#1-综合" class="headerlink" title="1.综合"></a>1.综合</h3><p>插值操作 Mustache</p>
<p>Mustache语法 (双大括号)<br>可以直接写变量<br>可以写简单的表达式<br>v-once<br>后面不需要跟任何表达式<br>表示元素和组件只渲染一次, 不会随着数据的改变而变化  </p>
<p>v-html<br>后面往往跟一个string类型<br>会将string的html解析出来并渲染  </p>
<p>v-text<br>与Mustache相似, 一般不用, 不灵活  </p>
<p>v-pre<br>用于跳过这个元素和它子元素的编译过程, 用于显示原本的Mustache语法  </p>
<p>v-cloak<br>在某些情况下, 我们浏览器可能会直接显示出未编译的Mustache标签  </p>
<p>v-bind<br>作用: 动态绑定属性<br>简写: :</p>
<p>条件判断</p>
<p>v-if<br>v-else-if<br>v-else<br>v-show  </p>
<p>当条件为false的时<br>v-if: 指令的元素, 不会渲染到dom中<br>v-show: dom增加一个行内样式display:   none<br>v-on<br>作用: 绑定事件监听<br>简写: @<br>写法:<br>    没有参数的情况下, 可以不写(); 如果方法本身有一个参数, 会默认将原生事件event参数传递进去<br>    如果传入某个参数, 同时需要event时, 可以通过$event传入时间</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;h2&gt;点击次数: &#123;&#123;counter&#125;&#125;&lt;/h2&gt;
  &lt;!--情况一: 方法没有参数--&gt;
  &lt;button @click=&quot;btnClick1&quot;&gt;按钮1&lt;/button&gt;
  &lt;button @click=&quot;btnClick1()&quot;&gt;按钮1&lt;/button&gt;

  &lt;!--情况二: 如果方法有参数--&gt;
  &lt;!--1.调用时不传入参数,会默认将event作为第一个参数传入--&gt;
  &lt;button @click=&quot;btnClick2&quot;&gt;按钮2&lt;/button&gt;
  &lt;!--2.调用时不传入参数,那么参数为undefined--&gt;
  &lt;button @click=&quot;btnClick2()&quot;&gt;按钮2&lt;/button&gt;

  &lt;!--情况三: 如果方法有参数,并且希望传入event--&gt;
  &lt;button @click=&quot;btnClick3(10, $event)&quot;&gt;按钮3&lt;/button&gt;
&lt;/div&gt;

&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  const app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
      counter: 0
    &#125;,
    methods: &#123;
      btnClick1() &#123;
        console.log(&#39;按钮1被点击&#39;);
      &#125;,
      btnClick2(payload) &#123;
        console.log(&#39;按钮2被点击&#39;, payload);
      &#125;,
      btnClick3(num, event) &#123;
        console.log(&#39;按钮3被点击&#39;, num, event);
      &#125;
    &#125;
  &#125;)
&lt;/script&gt;
</code></pre>
<h1 id="v-for遍历数组"><a href="#v-for遍历数组" class="headerlink" title="v-for遍历数组"></a>v-for遍历数组</h1><pre><code>// 遍历过程中, 没有使用索引值
&lt;li v-for=&quot;item in names&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;

// 遍历过程中, 获取索引值
&lt;li v-for=&quot;(item, index) in names&quot;&gt;&#123;&#123;index + 1&#125;&#125; - &#123;&#123;item&#125;&#125;&lt;/li&gt;

// 遍历对象的时候, 只有一个值, 活得的是value

// 获取对象的key和value 
&lt;li v-for=&quot;(value, key) in names&quot;&gt;&#123;&#123;value&#125;&#125; - &#123;&#123;key&#125;&#125;&lt;/li&gt;

// 获取对象的key和value和index 
&lt;li v-for=&quot;(value, key, index) in names&quot;&gt;&#123;&#123;value&#125;&#125; - &#123;&#123;key&#125;&#125; - &#123;&#123;index&#125;&#125;&lt;/li&gt;
</code></pre>
<p>官方推荐, 使用v-for的时候, 加上一个 key属性<br>key的作用是为了高效的更新虚拟DOM<br>key要具有唯一性, 不然就没意义  </p>
<pre><code>&lt;li v-for=&quot;(item, index) in names&quot; :key=&quot;item&quot;&gt;&#123;&#123;index + 1&#125;&#125; - &#123;&#123;item&#125;&#125;&lt;/li&gt;
</code></pre>
<h1 id="v-model表单绑定"><a href="#v-model表单绑定" class="headerlink" title="v-model表单绑定"></a>v-model表单绑定</h1><p>实现表单元素和数据的双向绑定</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;
    &#123;&#123;message&#125;&#125;
&lt;/div&gt;

cosnt app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        message: &#39;你好&#39;
    &#125;
&#125;)

// 界面的message数据改了, data里面的message就改变了, 是双向的
</code></pre>
<p>可以将v-model用于textarea元素</p>
<pre><code>&lt;textare v-model=&quot;message&quot;&gt;&lt;/textare&gt;
&lt;p&gt;输入内容: &#123;&#123;message&#125;&#125; &lt;/p&gt;
</code></pre>
<p>其他方法实现双向绑定</p>
<pre><code>// v-bind绑定一个value属性
// v-on指令给当前元素绑定input事件  
// 下面代码 等同于 使用v-model

&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; :value=&quot;message&quot; @input=&quot;message = $event.target.value&quot;&gt;
    &#123;&#123;message&#125;&#125;
&lt;/div&gt;

cosnt app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        message: &#39;你好&#39;
    &#125;
&#125;)
</code></pre>
<h3 id="v-model结合radio类型使用"><a href="#v-model结合radio类型使用" class="headerlink" title="v-model结合radio类型使用"></a>v-model结合radio类型使用</h3><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;label for=&quot;male&quot;&gt;
        &lt;inout type=&quot;radio&quot; id=&quot;male&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt;男
    &lt;/label&gt;
    &lt;label for=&quot;male&quot;&gt;
        &lt;inout type=&quot;radio&quot; id=&quot;female&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt;nv
    &lt;/label&gt;
    &lt;h2&gt;您选择的性别是: &#123;&#123;sex&#125;&#125;&lt;/h2&gt;
&lt;/div&gt;

cosnt app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        sex: &#39;男&#39;
    &#125;
&#125;)
</code></pre>
<h3 id="v-model结合checkbox类型使用"><a href="#v-model结合checkbox类型使用" class="headerlink" title="v-model结合checkbox类型使用"></a>v-model结合checkbox类型使用</h3><p>单选框</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;label for=&quot;agree&quot;&gt;
        &lt;inout type=&quot;checkbox&quot; id=&quot;agree&quot;  v-model=&quot;isAgree&quot;&gt;同意
    &lt;/label&gt;
    &lt;buttion :disabled=&quot;!isAgree&quot;&gt;下一步&lt;/button&gt;
&lt;/div&gt;

cosnt app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        isAgree: false
    &#125;
&#125;)
</code></pre>
<p>多选框</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;label for=&quot;agree&quot;&gt;
        &lt;inout type=&quot;checkbox&quot; value=&quot;足球&quot; v-model=&quot;hobbies&quot;&gt;足球
    &lt;/label&gt;
    &lt;label for=&quot;agree&quot;&gt;
        &lt;inout type=&quot;checkbox&quot; value=&quot;篮球&quot; v-model=&quot;hobbies&quot;&gt;篮球
    &lt;/label&gt;
    &lt;label for=&quot;agree&quot;&gt;
        &lt;inout type=&quot;checkbox&quot; value=&quot;羽毛球&quot; v-model=&quot;hobbies&quot;&gt;羽毛球
    &lt;/label&gt;
    &lt;h2&gt;您的爱好是: &#123;&#123;hobbies&#125;&#125;&lt;/h2&gt;
&lt;/div&gt;

cosnt app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        isAgree: false,
        hobbies: []
    &#125;
&#125;)
</code></pre>
<h3 id="v-model结合select类型使用"><a href="#v-model结合select类型使用" class="headerlink" title="v-model结合select类型使用"></a>v-model结合select类型使用</h3><p>下拉框单选</p>
<p>v-model绑定的是一个值<br>当选中option中一个时, 会将它对应的value赋值到mySelect中</p>
<pre><code>&lt;select v-model=&quot;mySelect&quot;&gt;
    &lt;option value=&quot;apple&quot;&gt;苹果&lt;option&gt;
    &lt;option value=&quot;orange&quot;&gt;橘子&lt;option&gt;
    &lt;option value=&quot;banana&quot;&gt;香蕉&lt;option&gt;
&lt;/select&gt;
&lt;p&gt;您最喜欢的水果: &#123;&#123;mySelect&#125;&#125;&lt;/p&gt;
</code></pre>
<p>下拉框多选</p>
<p>v-model绑定的是一个数组<br>当选择多个值时,会将选中的option对应的value添加到数组mySelect中</p>
<pre><code>&lt;select v-model=&quot;mySelect&quot; multiple&gt;
    &lt;option value=&quot;apple&quot;&gt;苹果&lt;option&gt;
    &lt;option value=&quot;orange&quot;&gt;橘子&lt;option&gt;
    &lt;option value=&quot;banana&quot;&gt;香蕉&lt;option&gt;
&lt;/select&gt;
&lt;p&gt;您最喜欢的水果: &#123;&#123;mySelect&#125;&#125;&lt;/p&gt;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/10/vue1/" data-id="cl6on3sz40000ukw992e212i9" data-title="vue1" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/19/vue6/">vue6</a>
          </li>
        
          <li>
            <a href="/2022/08/17/vue5/">vue5</a>
          </li>
        
          <li>
            <a href="/2022/08/16/vue4/">vue4</a>
          </li>
        
          <li>
            <a href="/2022/08/15/vue3/">vue3</a>
          </li>
        
          <li>
            <a href="/2022/08/14/vue2/">vue2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Ma<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>